<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[协议]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[串口协议 波特率 数据位 停止位 奇偶校验RXD TXD GND SPI四线协议:时钟、从机选择使能、 有多个从机，但只能存在一个主机，通过使能线选择 i2c两线：数据线、时钟线 区别:SPI通过片选信号线SS来决定要通讯的从机，I2C通过给每个I2C器件分配唯一的地址 esp8266 TCP通讯https://blog.csdn.net/qq_28877125/article/details/62898895]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[线程与进程]]></title>
    <url>%2F2018%2F10%2F24%2F%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程与线程的区别（并行与并发） 进程间的通信、流程图 线程的同步 线程池 进程与线程的区别根本区别：进程是系统资源分配的基本单位，线程是任务调度和执行的基本单位 开销区别：进程有自己的独立地址空间，开销较大。而线程是共享进程中的数据的，开销较小 通信方式：进程通信方式：管道、FIFO(又名管道)、消息队列、信号、信号量、共享内存区 线程通信方式：互斥、信号、 稳定性：一个进程出错不会影响其他进程。多线程程序只要一个线程出错，整个进程就会出错 进程间的通讯SYSTEM V和POXISPOXIS:每个IPC对象是有名称的system v :key_t 生成钥匙 看到通讯的本质PIPE和FIFO：随进程持续建立、打开、删除的方式不同外，通过内核缓冲区实现数据传输。通过文件描述符读写 消息队列：随内核持续提供字节流，优先级机制 共享内存：速度最快 内存映射：mmap映射普通文件，建立共享内存。最后完成操作后才将文件回写 system v：通过映射特殊文件系统shm中的文件实现进程间的共享内存通信。 信号量：只能用来同步 线程间的通信(或者叫同步)锁机制：互斥锁、读写锁、条件变量 互斥锁：排他防止数据被更改 读写锁：允许同时读，对写是互斥的 条件变量：配合互斥锁使用信号量机制：包括无名线程信号量和命名线程信号量信号机制：类似进程间的信号处理 信号和信号量信号：控制一系列信号。信号量：我先关注线程的同步 PV操作：是不可中断的过程，信号量的值只能由其改变 临界区：一次仅允许一个进程使用的共享资源使用临界资源之前执行P操作，用完执行V操作P：取出 V：送货 进程间通信参考 线程池：结构： 工作线程 任务队列 线程管理 任务接口 1、预先启动一些线程，线程负责执行任务队列中的任务，当队列空时，线程挂起。 2、调用的时候，直接往任务队列添加任务，并发信号通知线程队列非空。 3、管理线程负责监控任务队列和系统中的线程状态，当任务队列为空，线程数目多且很多处于空闲的时候，便通知一些线程退出以节约系统资源；当任务队列排队任务多且线程都在忙，便负责再多启动一些线程来执行任务，以确保任务执行效率。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[TCP与UDP]]></title>
    <url>%2F2018%2F10%2F24%2FTCP%E4%B8%8EUDP%2F</url>
    <content type="text"><![CDATA[发现用历史推演的角度去看问题会更有逻辑 TCP与UDP的区别 TCP的握手和挥手 UDP的建立连接 sock的bind使用 7层协议和四层协议 7层协议和四层协议OSI模型应用层 应用表示层 解决不同系统间的通讯语法问题会话层 管理程序间的通信传输层 TCP/UDP网络层 路由器数据链路 交换机(mac)物理层 网线 TCP/IP四层协议应用层传输层网络层数据层 TCP与UDP区别 TCP面向连接，因此传输较慢、占用系统资源多。UDP无连接，TCP的大部分缺点转换成了其优点 TCP提供可靠的服务，传输可靠的数据。UDP尽力交付，传输大量的数据 TCP面向字节流，UDP面向报文 TCP只能一对一，UDP可以多种形式TCP常见服务：邮件、POP、HTTP、FTP、SSH TCP的握手和挥手为什么是3次握手 四次挥手：结束的时候不会一下就断开，要给他完成任务的时间三次握手CLIENT SERVER SYN=1,seq(随机产生的)=x—–&gt; &lt;—- SYN=1,ACK=1,ack=x+1,seq=y ACK=1,ack=y+1,seq=x+1 这里client检测传来的ack ACK后发送数据 传过去后server也会检测。SEQ的作用：序列号 防止传错，便于接收方能按顺序接受数据 四次挥手 FIN=1 seq=u ACK=1,ack=u+1 seq=v FIN=1,ACK=1,ack=u+1,seq=w ACK=1,seq=u+1,ack=w+1 sock完成TCP/UDPTCP 创建套接字 字节流 绑定IP和端口 bind() 监听 listen 接收accept 发送send UDP 创建套接字 数据报 绑定IP和端口 bind() 接收recvfrom 发送sendto 面向数据报：发送端调用一次sendto, 发送100个字节, 那么接收端也必须调用对应的一次recvfrom, 接收100个字节，而不能循环调用10次recvfrom, 每次接收10个字节; 面向字节流：上述两种都可以 十八、请简述设计一个tcp并发服务器的基本流程，并且将关键函数写出 ）（5分）socket()：创建一个socket文件描述符bind(): 绑定服务器的ip地址和端口号(以太网地址结构)Listen(): 监听客户端select(): 轮训所有监听的文件描述符acept(): 等待客户端的连接]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面试题]]></title>
    <url>%2F2018%2F10%2F23%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[112printf(&quot;%f&quot;,5);printf(&quot;%d&quot;,5.01);//输出的是.01的二进制 printf(“%f”,5) 首先5是int型的，在内存中占有4B，而输出确要是8B个字节，5在内存中为0000 0000 0000 0000 0000 0000 0000 0101 按%f输出还必须加入0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 0101 才行，由于double类小数点后面只保留6位，所以不可能取到有非0的101处，所以答案为0.000000。 printf(“%d”,5.01); 2123456781 void main()2 &#123;3 unsigned int a = 0xFFFFFFF7;4 unsigned char i = (unsigned char)a;5 char* b = (char*)&amp;a;//强转是为了完成赋值6 *b只能保存一个字节的数据7 printf(&quot;%08x, %08x\n&quot;, i, *b);8 &#125; 要点：%08x 输出十六进制 不够8位补零 0x会输出。i被赋值为f7，按照格式输出 0x00 00 00 f7b指向a的低字节内存。也就是0xA7 b有符号。(char b = (char*)&amp;a大坑)[https://blog.csdn.net/race604/article/details/6725475] 3一个栈的入栈序列为ABCDEF，则不可能的出栈序列是一个个分析是不可能的，找到规律！ 1、在原序列中相对位置比它小的，必须是逆序；2、在原序列中相对位置比它大的，顺序没有要求；3、以上两点可以间插进行。 看第一个是什么：如果是F 那么 只能是EDCBA 如果是D 那么 D前面的只能是CBA EF随意(例子)[https://www.jianshu.com/p/e91cdf745048] 4过桥问题：一个手电筒，每次两个人 A B C D过桥时间1 3 5 6 最短：AB 3 A 1 送手电 CD 6 B 3 送手电 AB 3 5123456(考虑内存重叠的mystrcpy)[https://blog.csdn.net/nyist327/article/details/46533829]char *strcpy(char *dst, const char *src);实现strcpy函数解释为什么要返回char *假如考虑dst和src内存重叠的情况，strcpy该怎么实现 123456789101112131415161718192021222324252627282930//实现1char * strcpy(char* _Dest, const char* _Source)&#123; //检查传入参数的有效性 assert(NULL != _Dest); assert(NULL != _Source); if (NULL ==_Dest || NULL == _Source) return NULL; char* ret = _Dest; while((*_Dest++ = *_Source++) != &apos;\0&apos;) ;\\结尾的时候会赋值&apos;\0&apos; return ret;&#125;//实现2char * strcpy(char* _Dest, const char* _Source)&#123; //检查传入参数的有效性 assert(NULL != _Dest); assert(NULL != _Source); if (NULL ==_Dest || NULL == _Source) return NULL; char* ret = _Dest; int i = 0; for (i = 0; _Source[i] != &apos;\0&apos;; i++) &#123; _Dest[i] = _Source[i]; &#125; _Dest[i] = &apos;\0&apos;;//结尾赋值&apos;\0&apos; return ret;&#125; 源字符串参数用const修饰，防止修改源字符串。 (A)不检查指针的有效性，说明答题者不注重代码的健壮性。 考虑内存覆盖的字符拷贝：内存覆盖：src和dest的地址靠得很近，在给dest赋值的过程中会改变还未赋值给dest的src中的内容 递归实现数字逆序后存入数组123456789101112131415161718192021222324252627282930#include&lt;stdio.h&gt;#include&lt;string.h&gt; /* /////////////////////////////////////////*//*将一整数逆序后放入一数组中（要求递归实现）*//*//////////////////////////////////////////*/ void convert(int *result, int n); void main()&#123; int num,result[20],i,n; printf(&quot;输入整数的位数\n&quot;); scanf(&quot;%d&quot;,&amp;n); printf(&quot;请输入整数\n&quot;); scanf(&quot;%d&quot;,&amp;num); convert(result,num); for(i = 0;i &lt; n;i++) printf(&quot;%d &quot;,result[i]); printf(&quot;\n&quot;);&#125; void convert(int *result, int n)&#123; if(n &gt;= 10) &#123; convert(result+1,n/10); &#125; *result = n%10;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[指针的骚操作]]></title>
    <url>%2F2018%2F10%2F22%2F%E6%8C%87%E9%92%88%E7%9A%84%E9%AA%9A%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[指针确定循环条件：inverte(int x,int n){ int p,temp,i,j,m=(n-1)/2; i = x;//起始的元素 j = x + n -1;//最后的元素 p = x + m;//循环终极点，很巧妙的一步，免去再定义一个用来循环的量。直接比较地址，地址也是一位一位移动的。 for(;i&lt;=p;i++,j–) { temp = i; i = j; j = temp; } return 0;}]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[金玉良言]]></title>
    <url>%2F2018%2F10%2F20%2F%E9%87%91%E7%8E%89%E8%89%AF%E8%A8%80%2F</url>
    <content type="text"><![CDATA[内存中的数据是不存在符号位的,全都是数据位，符号位只存在与编译器中负数存储形式：绝对值的原码取反加1char c = 128；存储形式：1000 0000 有符号位-1 取反=128 看符号位 -128printf(“%d”,c);输出负数规律：有符号的数据类型都有一个最大值 和最小值最大值：0111….最小值: 1000…. 绝对值比最大值大一 云端的才是安全的因为：硬盘损坏，手机更换，u盘丢失。所以：把学到的知识，写到blog上去，福利他人，加强认识。 123456789101112- 好的书：百度网盘建立书籍收藏的文件夹- 代码：git上传环境配置好- 常用软件及其和谐放到同一文件夹并写好教程- 视频：在线看- 图片：QQ空间 经常清理垃圾，丢掉无用的东西.电脑经常清理，也会更快速，把重要的东西丢到云端，近段时间常用的东西放在桌面。 指针：我们等级严明也讲义气 讲义气:在同一个函数中直接可以赋值，改变指向的地址 等级分明：在函数体外先要改变我，请亮出你比我多的那颗星！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[笔试答题积累]]></title>
    <url>%2F2018%2F10%2F19%2F%E7%AC%94%E8%AF%95%E7%AD%94%E9%A2%98%E7%A7%AF%E7%B4%AF%2F</url>
    <content type="text"><![CDATA[逆序类：1、将一个字符串逆序2、将一个链表逆序 转换类： 6、字符串转换为整数7、整数转换为字符串8、将小写字母转换成大写字母 3、计算一个字节里（byte）里面有多少bit被置14、搜索给定的字节(byte)5、在一个字符串中找到可能的最长的子字符串 链表类 字符操作类]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[malloc]]></title>
    <url>%2F2018%2F10%2F19%2Fmalloc%2F</url>
    <content type="text"><![CDATA[学习概念 是什么？不是什么？和其他有什么异同？ 是什么在头文件&lt;stdlib.h&gt;下(这么知道的？man malloc)void *malloc(size_t size);用来分配空间，返回指向被分配的空间的指针。 腾达面试题目123456789101112int m(char * p)&#123; p=malloc(10); return 1;&#125;int main() &#123; char *p; m(p); //传递的是p的地址的值strcpy(p,&quot;abc&quot;); return 0;&#125; 分析：函数目的是将malloc返回的值传回主函数。传参：指针p的地址注意：不是指针指向的地址 12345678910111213int m(char **p)&#123; *p = (char *)malloc(10); return 1;&#125;int main()&#123; char *p; m(&amp;p);//传递p的地址 **p strcpy(p,&quot;abc&quot;); free(p); return 0;&#125; 确定传参的内容是：指针的地址 指针地址表示法：** p 确定形参的定义：char **p 这题的其他解法：全局变量或者static变量。 以小见大，方便理解123456789101112131415161718192021222324int change(int x,int y)&#123; int temp; temp = x; x = y; y = temp;&#125;这个函数不能将从主函数传来的值交换。int change_right(int *x,int *y)&#123; int temp; temp = *x; *x = *y; *y = temp;&#125;从主函数 &amp;x,&amp;y 得到参数的地址int * 接收地址。*x:给其赋值就是改变其地址的值！！！！这里对指针的定义更加明确了 int *x x的值就是一个地址 可以通过赋值改变 *x 就是存储在地址中的值 x自己还有一个地址，如果向改变这个地址要用**x]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[类型转换及优先级]]></title>
    <url>%2F2018%2F10%2F19%2F%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[类型转换1234567 高 double ←← float ↑ ↑ ↑ long ↑ ↑ ↑ unsigned ↑ ↑ 低 int ←← char,short 规律：值变大 精度变大 运算符号优先级别这个必须要记忆！！！ 初等单目一二级， // 初等运算符和单目运算符分别是第1、2优先级 乘除求余加减移， // 这句里面的运算符全归为算术运算符，移表示移位 关系等于不等于， // 关系运算符（&lt; &lt;= &gt; &gt;=） 按位与来异或或， // 位运算符优先级顺序: &amp; -&gt; ^ -&gt; | 逻辑与或条件弱， // 逻辑运算符优先级顺序: &amp;&amp; -&gt; ||，后面跟着优先级比较低(弱)的条件运算符 赋值逗号一点破。 // 赋值，逗号最低 注意结合性：从右到左：单目、条件、赋值！ 作者：skywalker_leo来源：CSDN原文：https://blog.csdn.net/skywalker_leo/article/details/6237222版权声明：本文为博主原创文章，转载请附上博文链接！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[const]]></title>
    <url>%2F2018%2F10%2F19%2Fconst%2F</url>
    <content type="text"><![CDATA[学习概念 是什么？不是什么？和其他有什么异同？ 是什么 const 修饰的数据类型是指常类型，常类型的变量或对象的值是不能被更新的。 不是什么？ 异同？ 例子int const a；const int a；这两个一样 先看一下 int a是什么含义？一个指向int的指针aa是指向int型数据的指针：是一个地址 a是指向的数据：是一个数据 const int a：const修饰int 一个指向const int的指针a`int const a：const 修饰a a就是int 只是不好理解 意义同上`int const a:const 修饰a 一个指向int型的常量指针a那么，指向const int 的常指针如何表示？const int const a 方便理解的形式int const *a const 同上what fuck!!!]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[static]]></title>
    <url>%2F2018%2F10%2F19%2Fstatic%2F</url>
    <content type="text"><![CDATA[学习概念 是什么？不是什么？和其他有什么异同？ 好习惯：只用于本文件的函数要全部使用static关键字声明，这是一个良好的编码风格。 是什么： 在一函数体内，调用时其值不变，在主或子函数中赋值有效。 在一函数体内，它是一个本地的全局变量。 一个被声明为静态的函数只可被这一函数内的其它函数调用。那就是，这个函数被限制在声明它的模块的本地范围内使用。 另外一种说法： 设置变量的存储域，函数体内static变量的作用范围为该函数体，不同于auto变量，该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值； 限制变量的作用域，在模块内的static全局变量可以被模块内所用函数访问，但不能被模块外其它函数访问； 限制函数的作用域，在模块内的static函数只可被这一模块内的其它函数调用，这个函数的使用范围被限制在声明它的模块内； 不是什么：不是普通函数 和全局变量有区别全局变量还可以在定义的函数体外访问注意一个知识点：定义变量和声明变量123456789（1）main.c文件 #include &quot;common.h&quot; unsigned char key; 定义全局变量 （2）common.c文件： #include &quot;common.h&quot; extern unsigned char key; //声明]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[stm32中断]]></title>
    <url>%2F2018%2F10%2F18%2Fstm32%E4%B8%AD%E6%96%AD%2F</url>
    <content type="text"><![CDATA[学习概念 是什么？不是什么？和其他有什么异同？ 使用 怎样使用正确？需要注意什么？容易出错的地方？ 中断的概念 是什么：解决轮询的资源浪费，功能有类似之处。 不是什么：中断函数无返回值，无参数，不是普通函数。 异同：暂时不知如何比较 中断的使用 怎样正确 中断函数保存到startup_stm32f40xx.s例如：IMPORT gec_key0_handlerfun或者更改 12345EXPORT EXTI0_IRQHandler //任意更改！ EXPORT EXTI1_IRQHandler EXPORT EXTI2_IRQHandler EXPORT EXTI3_IRQHandler EXPORT EXTI4_IRQHandler 配置GPIO(略) SYSCFG配置 123RCC_APB2PeriphClockCmd(RCC_APB2Periph_SYSCFG,ENABLE);//使能syscfg时钟RCC_APB2PeriphClockCmd(RCC_APB2Periph_EXTIT,ENABLE);//使能外部中断时钟SYSCFG_EXTILineConfig(EXTI_PortSourceGPIOA,EXTI_PinSource0);//外部中断输入引脚的选择 EXTI外部中断的配置 1234567EXTI_InitTypeDef q;q.EXTI_Line = EXTI_Line0| EXTI_Line2| EXTI_Line3| EXTI_Line4;q.EXTI_Mode = EXTI_Mode_Interrupt;q.EXTI_Trigger = EXTI_Trigger_Falling;q.EXTI_LineCmd = ENABLE;EXTI_Init(&amp;q); NVIC 配置 12345678NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);NVIC_InitTypeDef r;r.NVIC_IRQChannel = EXTI0_IRQn;r.NVIC_IRQChannelPreemptionPriority = 2;r.NVIC_IRQChannelSubPriority = 2;r.NVIC_IRQChannelCmd = ENABLE; NVIC_Init(&amp;r); 中断标志的获取与清零EXTI_GetITStatus(EXTI_Line0) == SETEXTI_ClearFlag (EXTI_Line0); 需要注意什么startup_stm32f40xx.s 配置中断函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170.STM32F4xx 中断总概述 任何中断产生到cpu的响应,都需经过两大阶段 可屏蔽中断:中断产生后CPU不会收到中断信号 或 cpu收到中断信号但不受理该中断 1) 中断源控制 中断源 也就是产生中断事件的设备,设备能不能产生终端,必须要有一根中断请求线(IRQ Requst Line) 链接到 中断控制器(NVIC)的中断输入引脚上 如果: 外设利用 中断请求线链接到了 中断控制器,则表示 外设可以产生中断事件 否则,外设无法产生中断 2) 中断控制器控制 NVIC 对所有的中断输入引脚进行管理和控制,给CPU一个中断信号,通知CPU某某设备产生了中断 CPU再按约定,切换模式到HandlerMOde,再到特定的地址上的中断向量表中去取&quot;中断处理函数&quot;执行 一个设备产生的终端,首先要经过&quot;中断源&quot;这一级,&quot;中断源&quot;可以 屏蔽或使能(Enable/disable)自己的中断,即使外部电路产生了一个&quot;事件&quot; &quot;中断源&quot;也可以不向上级(NVIC)报告 中断控制器(NVIC): 他可以控制中断,他在收到外设的中断信号后,可以选择enable/disable这个中断 意思是说,NVIC可以选择 是否向上级(CPU)报告这个中断事件 4.STM32外部中断 人为的把中断分为 : 外设中断 和 外部中断 外设中断: 指UART/TIMER/IIC/SPI....等设备产生的中断, 这些设备不需要人去设置 外部中断: 指由GPIO链接的外部电路所产生的终端事件 需要依赖于外部电路,而且,GPIO还可以 软件配置类型(上升沿/下降沿)产生中断 上升 : 0 --- &gt; 1 上坡 下降: 1 --- &gt; 0 下坡 请参考&lt;STM32F4xx外部中断处理逻辑&gt; GPIO中断的过程: GPIO控制器 ---&gt; SYSCFG选择器 ---&gt; EXTI(External Interrupt)外部中断控制器 ----&gt; NVIC中断控制器 ----&gt; CPU 中断向量表 --&gt; 寻址 5.外部中断的代码实现 外部中断函数名 KEY0 ---&gt; PA0 ---&gt; EXTI0(使能GPIO组中断,0表示 PA0,PB0,PC0,..,PI0) ---&gt; NVIC -----&gt; CPU中断向量表 ----&gt; EXTI0_IRQHandler KEY1 ---&gt; PE2 ----&gt; EXTI2 .... KEY2 ---&gt; PE3 ---&gt; EXTI3 KEY3 ---&gt; PE4 ---&gt; EXTI4 1) 配置GPIO 使能GPIO分组时钟 RCC_AHB1..... GPIO_Init() ----&gt; 输入模式 2) SYSCFG配置 使能SYSCFG的时钟 RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState); 外部中断输入引脚的选择 void SYSCFG_EXTILineConfig ( uint8_t EXTI_PortSourceGPIOx, // 选择GPIO口分组 //x = A,B,C,D,..,I // EXTI_PortSourceGPIOA uint8_t EXTI_PinSource0 //选择GPIOx组的引脚的编号 //x = 0,1,2,3,...,15 //EXTI_PinSource0 ); 3) EXTI外部中断的配置 EXTI_Init用来配置一个外部中断 void EXTI_Init ( EXTI_InitTypeDef * EXTI_InitStruct ) 参数结构体如下: typedef struct &#123; uint32_t EXTI_Line; //指定要初始化 的外部中断的编号 // EXTI_Line0 EXTI_Line1 ..... //如果有多个需要指定,则可以用 &apos;|&apos; EXTIMode_TypeDef EXTI_Mode; //指定外部中断的模式 // EXTI_Mode_Interrupt 中断模式 // EXTI_Mode_Event 事件模式 EXTITrigger_TypeDef EXTI_Trigger; // 指定外部中断线的触发方式,选择上升/下降沿触发 //EXTI_Trigger_Rising = 0x08, 上升沿 //EXTI_Trigger_Falling = 0x0C, 下降沿 //EXTI_Trigger_Rising_Falling = 0x10 双边沿触发 // 上述三个任选一个 FunctionalState EXTI_LineCmd; // 使能或禁止外部中断 //ENABLE 使能 //DISABLE 禁止 &#125;EXTI_InitTypeDef; ---------------------------- EXTI_ClearFlag 用来清除掉EXTI_Line 指定的中断 pending为,这个函数一般是在中断处理完后调用 void EXTI_ClearFlag ( uint32_t EXTI_Line ) 用来判断中断是否产生 FlagStatus EXTI_GetFlagStatus ( uint32_t EXTI_Line ) ITStatus EXTI_GetITStatus ( uint32_t EXTI_Line ) EXTI_Line 表示要获取状态的 中断线(哪个外部引脚) 返回值: SET 表示中断触发 RESET 表示中断未触发 比如: if(EXTI_GetITStatus(EXTI_Line0) == SET) &#123; //表示 EXTI_Line0 产生了中断 &#125; if(EXTI_GetITStatus(EXTI_Line1) == SET) &#123; //表示 EXTI_Line1 产生了中断 &#125; .... if(EXTI_GetITStatus(EXTI_Line15) == SET) &#123; //表示 EXTI_Line15 产生了中断 &#125; 4)NVIC 配置 NVIC_Init void NVIC_Init(NVIC_InitTypeDef* NVIC_InitStruct) typedef struct &#123; uint8_t NVIC_IRQChannel; //指定要初始化的中断通道(中断编号) //外部中断0编号 EXTI0_IRQn //串口0编号 UART0_IRQn // 外设编号 外设名_IRQn uint8_t NVIC_IRQChannelPreemptionPriority; //抢占优先级 uint8_t NVIC_IRQChannelSubPriority; //子优先级 NVIC允许用户给每一个中断通道的优先级作配置,每个中断的优先级有4bits(0~15) 数值越小,则优先级越高,中断的优先级分为两种 抢占优先级 决定是否可以抢占正在执行处理的中断 当一个中断A正在执行时(中断处理函数已经在执行),此时又产生了一个B中断 如果 B中断的抢占优先级 高于 A中断的抢占优先级,则暂停A中断的处理函数 转区执行 B中断的处理函数,返回后再继续执行A中断的处理函数 子优先级 决定如果两个或两个以上的同抢占优先级的中断同时来,CPU优先处理谁的问题. 比如:两个 优先级为4的中断 A,B产生,而A的子优先级为 2 ,B的子优先级为3 则先执行 A中断(优先级数字越小,等级越高) 在抢占优先级相同时,子优先级越高,则&quot;优势&quot;越大 4bits = x bits(抢占优先级) + (4-x)bits(子优先级) NVIC_PriorityGroupConfig函数用来配置各占的Bit位数量 FunctionalState NVIC_IRQChannelCmd; //使能/禁止中断 // ENABLE 使能 // DISABLE 禁止 &#125; NVIC_InitTypeDef; NVIC_PriorityGroupConfig函数用来配置各占的Bit位数量 void NVIC_PriorityGroupConfig(uint32_t NVIC_PriorityGroup); NVIC_PriorityGroup_0 x(抢占优先级)占0bits NVIC_PriorityGroup_1 x(抢占优先级)占1bits NVIC_PriorityGroup_2 x(抢占优先级)占2bits NVIC_PriorityGroup_3 x(抢占优先级)占3bits NVIC_PriorityGroup_4 x(抢占优先级)占4bits 容易出错的地方 中断向量表]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[方法论]]></title>
    <url>%2F2018%2F10%2F18%2F%E6%96%B9%E6%B3%95%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[还记得刚进高中时，语文老师提出一个如何分析古诗的问题。我当时随便想了一下： 这首诗表达了什么感情作者是如何表达这种感情的作者为何要表达这种感情 我说出这几句话后，老师上第一节课时便当着全班的面问了我的名字。说明我那时已经掌握了分析诗歌的正确方法论，而这个方法是我想出来的，说明经过多年的古诗背诵，我悟得了诗歌得套路。 学习编程这么久，博客也写了但是效果却不好，现在分析原因，就是因为没有掌握正确的方法论。看到李笑来对概念的解释我决定试一试这个我觉得正确的方法论。 学习概念 是什么？不是什么？和其他有什么异同？ 使用 怎样使用正确？需要注意什么？容易出错的地方？ 现在我就写个例子，以后也要这样写。 cpu的大小端概念： 是什么：大端模式：数据低字节高地址，数据高字节低地址 小端模式：低字节低地址，高字节高地址 不是什么：是数据的字节 而不是位。 异同：暂时无对比对象 cpu的大小端验证： 正确的方法： 123456789101112131415161718192021222324252627方法一：公用体 公用空间 截取 int IsLitte＿Endian()&#123; union w &#123; int a; char b; &#125;c; c.a=1; return (c.b==1);//若处理器是Big_endian的，则返回false；若是Little_endian的，则返回true。&#125;方法二：强制类型转换bool或者int？ IsLitte_Endian()&#123;int a = 0x12345678;//int占用4字节，16进制的话一位相当4位2进制，4*8=32bit=4byteshort *p=(short*)&amp;a;//short占用2字节return (0x5678 == *p);//若处理器是Big_endian的，则返回false；若是Little_endian的，则返回true。&#125; 需要注意：单纯的赋值不能判断大小端口，要涉及地址。 容易出错的地方：直接用 int 赋值给char]]></content>
      <categories>
        <category>日积月累</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[二胡与编程]]></title>
    <url>%2F2018%2F10%2F16%2F%E4%BA%8C%E8%83%A1%E4%B8%8E%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[你就已经初步理解了编译器是什么，你只需要在将来加深这种理解。 –yinwang 小时候去学二胡，从来没有认真练过曲子，也没有感到高兴的时刻，但是花了很多钱，那时候用的是父母的，不怎么心疼。学了5年，应该是初步理解二胡的一些技巧，而在大一的时候我花了很多时间去加深了一些理解。后面真的能全身心的投入去演奏，感受曲子中的各种感情。自2018-7月到今天，学习c语言3个多月，应该是初步理解了一些c语言的知识，我也希望在工作中能加深对它的理解。 有段时间练习二胡的感觉很好，练习各种曲子，基本是几遍就可以离谱表演。现在认真想想，应该是练琴的时候刺激到了大脑的某个部位，提升了其能力。现在我分析一下： 练琴时心无旁骛，沉浸在自己的世界，就是可怜了我那不打游戏的室友； 练习的都是自己很喜欢的曲子，听过许多遍，旋律已十分熟悉； 练琴时，先把曲子的整体架构梳理清楚了，难点和需要注意的地方都会多多练习，有段时间很花心，听一首喜欢一首，谱子都没有，或者就随便翻一个谱子，边听边练，练了几下练不好就不练了，这个就是总听它们说的无脑练习吧，不动脑子去练习，如果毅力够，也许能花很多时间完成任务。不过这个毅力不能叫毅力，这是一种精神的沦陷，陷入其中无法自拔。做事得动脑子啊（说到动脑子，我买东西的时候会货比三家，选择适合自己的，价格又不贵的，总会花很多时间在选购上面，买来的东西自然不会太差，但是我也太容易沦陷了）！ 永远不可能“准备好”，准备得差不多就得上了 （买东西也是，以后买东西，问问人，多看看，不能超过1个小时，那些细微的差别没必要花上几个小时，不如去看看书，但是不能无脑！）。也许水平有限，但是不妨碍在有限的能力内做到力所能及的完美，练琴时发现有些地方实在是做不到，我一般会选择放慢节奏，如何死磕，先磕一会儿，实在不行，改改曲子呗。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[字节对齐]]></title>
    <url>%2F2018%2F10%2F09%2F%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[http://www.cnblogs.com/clover-toeic/p/3853132.html12345678910struct A&#123; int a; char b; short c;&#125;;struct B&#123; char b; int a; short c;&#125;; sizeof(strcut A)值为8；sizeof(struct B)的值却是12 x86 gcc 4字节对齐注意：有doble 时还是4字节对齐1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除； 2) 结构体每个成员相对结构体首地址的偏移量都是成员大小的整数倍，否则填充； 3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，否则填充； A = 4+1+1(根据条件2填充的)+2B = 1+3(根据条件2填充的)+4+2=10+2(根据条件3填充)]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2018%2F09%2F13%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[注意：hexo中要注意空格 显示更多和代码展示1&lt;!-- more --&gt; 标题：注意空格一级标题二级标题三级标题四级标题五级标题六级标题强调斜体，_斜体_粗体，粗体加粗并斜体 删除线：这样来 删除一段文本 嵌套： 动物 水生动物陆生动物 猴子人 程序猿攻城狮产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记射鸡虱 //这里需要注意，没有空行间隔，忽略降级引用标记 两栖类动物 大鳄鱼唐老鸭 两个回车结束引用,不在引用范围内了！ 表格： 列1 列2 列3 第1行 12 13 第2行 22 23 第3行 32 33 左对齐 右对齐 居中 Computer 5000 元 1台 Phone 1999 元 1部 链接：博客 标记作用：ctrl+a 引用： 你是？ 图片：注意后缀，要赋值图片的地址。1234void main() &#123; printf(“Hello, Markdown.”); &#125; ONE ONE_ONR ONE_TWO TOW -列表展示 -列表展示 -列表展示]]></content>
  </entry>
  <entry>
    <title><![CDATA[线程]]></title>
    <url>%2F2018%2F09%2F13%2F%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程与进程的关系线程是一个进程的某个分支，一个进程至少应该有一个线程进程是操作系统分配资源的最小单元 线程是系统调度的最小单位！线程API函数1234567891011121314创建线程#include &lt;pthread.h&gt;int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);参数： thread 用于保存 线程号(需要创建) attr 创建线程的属性 一般默认属性填写 NULL void *(*start_routine) (void *) 函数指针 指针的名字start_routine 指向一个什么样的函数 一个返回 void* 指针 并有一个void*参数的函数！ 函数原型： void* 函数名（void *）; 指向线程的处理函数的指针！ arg 线程处理函数的参数！(需要会转换)返回值： 成功返回0 失败返回错误编码 即非0的数据 ！ 具体请解析！ 12345678910111213141516171819202122线程退出自杀 #include &lt;pthread.h&gt;void pthread_exit(void *retval);参数： 返回指针 作为线程函数的返回值 可以 pthread_jion接收！他杀 #include &lt;pthread.h&gt;int pthread_cancel(pthread_t thread);功能： 其实就是相当于一个线程给指定的线程发送一个“杀死”或“取消”信号 参数： thread 即指定的线程号 返回值： 成功返回0 失败返回错误码！0值 具体请解析注意： 线程收到这个信号并不一定会退出 这取决于线程的属性！int pthread_setcancelstate(int state, int *oldstate);功能： 设置线程取消的属性参数： state 要设置的属性 PTHREAD_CANCEL_ENABLE 可被别人取消 PTHREAD_CANCEL_DISABLE 不可被别人取消 oldstate 指定保存旧属性的变量的地址返回值： 成功返回0 失败返回错误码！0值 12345678910111213141516171819202122等待线程退出 #include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **retval);参数： thread 指定要等待那个线程退出 retval 二级指针 执行线程退出的值！ 也就是 pthread_exit 的参数 成功： 返回0 失败返回错误码！0值 注意： pthread_join 有两个作用： 第一个： 阻塞 直到等待的线程退出 第二个： 线程退出并不代表资源回收 其可以回收资源 这个取决于线程的一个属性： detach state 分离属性！ PTHREAD_CREATE_DETACHED : detach state 分离状态 他死了 资源自动释放 PTHREAD_CREATE_JOINABLE : joinable state 这种状态需要 该函数来回收资源 如果不指定则默认该状态！#include &lt;pthread.h&gt;int pthread_detach(pthread_t thread);功能： 将指定的线程设置为 detach 属性 参数：指定 线程的 id 返回值：成功返回0 失败返回错误码注意：如果线程已经处于分离状态再次设置分离状态 会导致状态不确定性 应禁止设置多次！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[共享内存和信号量]]></title>
    <url>%2F2018%2F09%2F13%2F%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%2F</url>
    <content type="text"><![CDATA[123456789函数汇总： 消息队列 信号量： 共享内存头文件 &lt;sys/msg.h&gt; &lt;sys/sem.h&gt; &lt;sys/shm.h&gt;创建或打开IPC msgget() semget() shmget() ***get()控制IPC操作 msgctl() semctl() shmctl() ***ctlIPC操作函数 msgsnd/msgrcv semop shmat/shmdt 12345678910#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;key_t ftok(const char *pathname, int proj_id);功能：用来生成一个唯一的System V IPC对象的KEY!原理: 生成算法 是用一个已经存在的路径名 和一个整数组成和一个 key_t!参数： pathname 一个已经存在的路径 proj_id 一个整数标志返回值：成功返回一个 键！ 失败返回-1 同时 errno被设置！ ex: p1 与 p2 进行通信 则p1 与 p2 的钥匙要相同 如何做？ p1：key_t p1_key = ftok(“/home”,122);p2: key_t p2_key = ftok(“/home”,122);要保持一模一样！ 共享内存在内核或者设备内存中开辟一块空间进程A 可以将这块内存映射到自己的进程空间进程B 也可以将这段空间那么如果A 修改了 这个空间的内容，就对应的修改了B中的内容！映射： 形成一一对应的关系API函数1234567891011创建或者打开一个共享内存 #include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmget(key_t key, size_t size, int shmflg);参数： key: 获取的钥匙 size 共享内存的大小 shmflg 标志位 1、创建IPC_CREAT | 权限位 2、 0 打开 返回值： 成功返回共享内存的id 失败返回-1 错误被存放于errno 12345678910111213映射/解映射#include &lt;sys/types.h&gt;#include &lt;sys/shm.h&gt;void *shmat(int shmid, const void *shmaddr, int shmflg);参数： shmid:共享内存的id shmaddr NULL 由操作系统自行分配 shmflg 映射标志 1、SHM_RDONLY 只读映射 2、0 读写 返回值： 成功返回映射区域的首地址 失败返回 NULL 错误存放在 errnoint shmdt(const void *shmaddr);参数： 映射区域的首地址！ 12345678910对于共享内存的操作控制 #include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmctl(int shmid, int cmd, struct shmid_ds *buf);参数： shmid 共享内存id cmd 当 cmd == IPC_RMID 时写NULL返回值： 成功返回 0 失败返回-1 错误存放在errno ##信号量如果有两个或者两个以上的进程访问同一块共享资源（可以是硬件 也可以是软件）！并且这个资源的访问具有排他性 ，那么我们就需要保证这个资源访问的时候 是有序访问 否则会出现不可预知结果！ 进程中不同线程进行同步机制的一种手段！ API函数12345678910111213a、创建一个信号量#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;int semget(key_t key, int nsems, int semflg);参数： key : 获取的钥匙 nsems: 信号量的个数 如果不要创建信号量集只要打开 这个参数的值应该为0 一旦创建该值不可更改！ semflg: 标志 1、创建 IPC_CREAT | 权限位 2、打开 0 返回值： 成功返回信号量集的id,失败返回-1 错误存储在 errno 1234567891011121314151617181920212223242526b、信号量操作函数 #include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;int semctl(int semid, int semnum, int cmd, ...);参数： semid 信号量集的id semnum 要操作其中的那个信号量即数组下标 [0 - nsems-1] cmd： 操作指令 常用的有： GETVAL:获取第几个信号量的值 SETVAL:设置第几个信号量的值 GETALL:获取所有信号量的值 SETALL: 设置所有信号量的值 IPC_RMID 删除信号量 ... 拓展的参数 可有可无 具体与 cmd有关！ 当cmd == IPC_RMID 时 第四个参数不要 当cmd == GETVAL 时 第四个参数也不要 返回值就是这个信号量的值！ 当cmd == SETVAL 第四个参数就是我要设置的值 当cmd == GETALL 第四个参数就是要保存每个信号量的地址 即 ushrot arr[] 当cmd == SETALL 第四个参数 就是要设置每个信号量的值的数组名 当cmd == IPC_SET 即设置这个信号量的属性 则第四个参数就是 struct semid_ds 的指针！ 当cmd == IPC_STAT 即获取这个信号量的属性 第四个参数表示将属性存放在这个地址中！ 返回值： 具体情况具体分析 12345678910111213141516171819202122232425262728c、PV 操作PV 操作是使用一个结构体(这个结构体包含在头文件中，定义一个结构体变量即可)来实现选择#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;struct sembuf&#123; unsigned short sem_num; /* semaphore number */ 指哪一个信号量 short sem_op; /* semaphore operation */ 信号量的操作 是一个 有符号的short类型 即做了相关操作后 semval = 原semval + sem_op sem_op &gt;0 表示 V 操作 一般会置为 +1 ！ ste_op &lt;0 表示 P操作 一般会置为 -1 ste_op ==0 自己尝试 看看是否就会阻塞！ short sem_flg; /* operation flags */ 操作标志： 0 表示默认 IPC_NOWAIT 非阻塞 如果是P操作 信号量没有获取到则直接走人 返回-1 表示不能获取！ SEM_UNDO 撤销 这个标志意义重大！ 为了防止进程带锁退出 如果设置了这个标志 内核会额外的记录该进程的PV 操作 当进程退出时 会还原！&#125;int semop(int semid, struct sembuf *sops, unsigned nsops);参数： semid 信号量集id sops: 操作选择的结构体指针 nsops:对几个信号量进行PV 表示有多少个信号量进行PV 操作 一般写一个1 ！返回值：成功返回0 失败返回-1 P操作和v操作如果一个进程需要等待即获取信号量，那么将会测试这个信号量的值 如果其值大于0 则信号量的值 -1该进程就会去访问这个资源，如果该信号量的值 等于0 那么这个进程将会阻塞等待信号量的到来！这就是信号量所说的 P操作 即Proberen 尝试！如果是互斥信号量 即互斥锁 就叫做 lock上锁！释放一个信号量如果一个进程使用完共享资源就需要释放 ，释放一个信号量时 如果当前有进程因等待信号量而被阻塞 那么其第一个将会恢复执行来访问资源，如果没有进程因等待而阻塞 那么信号量的值将+1这就是信号量中所说的 V操作 即 Verhogen 增加如果是互斥信号量 即互斥锁 就叫做 unlock 解锁]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[typedef]]></title>
    <url>%2F2018%2F09%2F11%2Ftypedef%2F</url>
    <content type="text"><![CDATA[define Type_D inttypedef int Type_T使用上述两个类型分别定义了两个变量Type_D a,b;Type_T x,y; 请问 a b x y分别是什么类型，使用 #define 与 typeof的区别是什么？那个更加好？typeof(a) = int*typeof(b) = int define 是字符替换int a,b; =&gt; int a,b; *号结合性！ typeof(x) = inttypeof(y) = int（int*） x,y;//但是语法不支持 编译不会过 C语言不可以给类型加()?注意：(类型说明符) 这是类型强转！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[fork经典]]></title>
    <url>%2F2018%2F09%2F11%2Ffork%E7%BB%8F%E5%85%B8%2F</url>
    <content type="text"><![CDATA[小收获：The Design of Everyday Thingsenv:Linux查看环境变量使用env命令显示所有的环境变量产生多少main？int main(int argc, char *argv[]) { fork(); fork() &amp;&amp; fork() || fork(); fork(); }解析总结：fork一次产生一个新进程，父进程一直跟随20个计算法：fork一次就加1 这里注意最后一个fork最后也会执行，第二行代码执行后最后一个fork也会执行 int main(void){ int i; for(i=0;i&lt;2;i++) { fork(); printf(“_\n”); } return 0;}答案：6 int main(void){ int i; for(i=0;i&lt;2;i++) { fork(); printf(““); } return 0;}答案：8这两题一样，这里先算出最后有多少进程，然后算出产生这些进程的过程。这里就是 2—&gt; 4 2+4=6注意：不带\n有两个会在缓冲区 因此会增加数量]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据存储空间]]></title>
    <url>%2F2018%2F09%2F11%2F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[程序在运行过程中,数据的存储问题Linux将程序运行时,地址空间分为了6个部分 栈: 用来存放局部变量 生成周期 随函数(代码块)持续性 除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的先进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。 堆: 用来存放动态分配的空间 malloc/realloc/calloc三个函数都是用来动态分配存储空间,并且返回分配的空间的首地址 生存周期,只要没有释放(free),那么随进程持续性 .bss: 用来存放未初始化(的全局变量和未初始化的 static修饰的变量注意：为0也是.bss中，默认也是0 随进程持续性:程序运行时就分配空间,程序结束时才回收(销毁.释放)空间 与bss相比，data就容易明白多了，它的名字就暗示着里面存放着数据。当然，如果数据全是零，为了优化考虑，编译器把它当作bss处理。通俗的说，data指那些初始化过（非零）的非const的全局变量。它有什么特点呢，我们还是来看看一个小程序的表现。 .rodata read ONLY data 用来存放只读数据 字符串常量 全局const变量 和 #define定义的常量 随进程持续性 .data 数据段 存放已初始化的全局变量和初始化的static修饰的变量 随进程持续性 .text 文本 文本段,用来存放代码/指令 也被称为 代码段 随进程持续性]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文档要求]]></title>
    <url>%2F2018%2F09%2F11%2F%E6%96%87%E6%A1%A3%E8%A6%81%E6%B1%82%2F</url>
    <content type="text"><![CDATA[如何做笔记？ 函数使用： 头文件 参数、说明 使用例子(贴代码) 特殊情况 2.编写代码时函数描述：12345678910111213/************************************************* Function: // 函数名称 Description: // 函数功能、性能等的描述 Calls: // 被本函数调用的函数清单 Called By: // 调用本函数的函数清单 Table Accessed: // 被访问的表（此项仅对于牵扯到数据库操作的程序） Table Updated: // 被修改的表（此项仅对于牵扯到数据库操作的程序） Input: // 输入参数说明，包括每个参数的作 // 用、取值说明及参数间关系。 Output: // 对输出参数的说明。 Return: // 函数返回值的说明 Others: // 其它说明*************************************************/ 3.用正确的反义词组命名具有互斥意义的变量或相反动作的函数:1add / remove begin / end create / destroy insert / delete first / last get / release increment / decrement put / get add / delete lock / unlock open / close min / max old / new start / stop next / previous source / target show / hide send / receive source / destination cut / paste up / down 4.编写代码说明：123456789/************************************************* Copyright (C), 1988-1999, Huawei Tech. Co., Ltd. File name: // 文件名 Author: Version: Date: // 作者、版本及完成日期 Description: // 用于详细说明此程序文件完成的主要功能，与其他块 // 或函数的接口，输出值、取值范围、含义及参数间的控 // 制、顺序、独立或依赖等关系 Others: // 其它内容的说明 Function List: // 主要函数列表，每条记录应包括函数名及功能简要说明]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>文档规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim技巧]]></title>
    <url>%2F2018%2F09%2F10%2Fvim%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[留下坑，慢慢填1. 标签页和多窗口2.]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[链接保存]]></title>
    <url>%2F2018%2F09%2F10%2F%E9%93%BE%E6%8E%A5%E4%BF%9D%E5%AD%98%2F</url>
    <content type="text"><![CDATA[arduino极客工坊项目实验室数据结构和算法排序算法参考 书籍保存 linux 递归一下 嵌入式学习网站守望者:什么都有点 linux别人的blog 嵌入式别人的blog LINUX什么都有点 嵌入式别人的blog2 51cto 吴川斌 左耳朵耗子 他人资料整理1 他人资料整理2 二次元程序员 github教程https://git-scm.com/book/zh/v2/ https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 成为理想程序员 C语言资料大全 grub使用教程http://wiki.ubuntu.org.cn/GRUB%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B ALL in one:make a kinds of sys boot from U盘https://www.aioboot.com/en/how-to-use/ 字节对齐 别出心裁Linux命令 cheat 极品飞车]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[信号]]></title>
    <url>%2F2018%2F09%2F07%2F%E4%BF%A1%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[常见信号12345678910111213141516171819202122SIGHUP 1 Term Hangup detected on controlling terminal or death of controlling process 在控制终端收到一个&quot;挂起&quot;或控制进程死亡时会收到该信号 SIGINT 2 Term Interrupt from keyboard 终止进程运行CTRL+C SIGQUIT 3 Core Quit from keyboard 发送停止信息并停止进程执行 CTRL+Z SIGILL 4 Core Illegal Instruction 遇到非法指令时产生的信号 SIGABRT 6 Core Abort signal from abort(3) 进程非正常终止时产生的信号 SIGFPE 8 Core Floating point exception 遇到一个浮点错误 a/0 SIGKILL 9 Term Kill signal 杀死进程 SIGSEGV 11 Core Invalid memory reference 非法内存引用(段错误) SIGPIPE 13 Term Broken pipe: write to pipe with no readers当管道写端写入数据时,管道读端收到该信号 SIGALRM 14 Term Timer signal from alarm(2) 定时器信号,超时信号 SIGTERM 15 Term Termination signal 终止信号 CTRL+\ SIGUSR1 30,10,16 Term User-defined signal 1 用户自定义信号1 SIGUSR2 31,12,17 Term User-defined signal 2 用户自定义信号2 SIGCHLD 20,17,18 Ign Child stopped or terminated子进程退出时,父进程收到该信号 SIGCONT 19,18,25 Cont Continue if stopped 继续执行一个挂起的进程 SIGSTOP 17,19,23 Stop Stop process 停止一个进程 SIGTSTP 18,20,24 Stop Stop typed at terminal 从终端上发起停止信号 SIGTTIN 21,21,26 Stop Terminal input for background process 后台试图从控制台输入 SIGTTOU 22,22,27 Stop Terminal output for background process 后台试图从控制台输出 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);int flg = 1;void my_sig_fun(int sig)&#123; printf(&quot;recv signal is:%d\n&quot;,sig); switch(sig) &#123; case SIGINT: printf(&quot;I can go out\n&quot;); flg = 0; break; case SIGALRM: printf(&quot;time out\n&quot;); flg = 0; break; &#125;&#125;int main(int argc,char *argv[])&#123; signal(SIGINT,my_sig_fun); signal(SIGALRM,my_sig_fun); alarm(5); //kill(atoi(argv[1]),SIGKILL);//atoi函数,是用来将给定的数字字符串转换为整数 while(flg) &#123; printf(&quot;zhuan bei shang!!\n&quot;); sleep(1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[系统io]]></title>
    <url>%2F2018%2F09%2F07%2F%E7%B3%BB%E7%BB%9Fio%2F</url>
    <content type="text"><![CDATA[openreadcloselseek：定位opendirreddir例子：bmp显示 目录读取（见项目电子相册）]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[标准io]]></title>
    <url>%2F2018%2F09%2F07%2F%E6%A0%87%E5%87%86io%2F</url>
    <content type="text"><![CDATA[需要：#include &lt;stdio.hFILE f1,f2;f1 = fopen(“./1.txt”,”r”);fclose(f1);12345678910111213141516171819202122a. 按字节读写:每次读写一个字节 getc/fgetc/getcharint getc(FILE *stream);int fgetc(FILE *stream);int getchar(void); putc/fputc/putcharint putchar(int c);int fputc(int c, FILE *stream);int putc(int c, FILE *stream); b. 按行读写: 每次读写一行数据 gets/fgetschar *gets(char *s);char *fgets(char *s, int size, FILE *stream); puts/fputs c. 直接读写: 每次按开发者需求进行读写 fread fwritesize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);size_t fwrite(const void *ptr, size_t size, size_t nmemb,FILE *stream);对于读写流来说,读写位置由光标决定: 读是读取光标所在位置的内容 写是写入光标所在的位置 每次读写后光标自动后移n个字节(n是读写的字节数) 1234567定位int fseek(FILE *stream, long offset, int whence);SEEK_SET 表示&quot;光标&quot;相对于 文件头移动SEEK_CUR 表示&quot;光标&quot;从当前位置移动SEEK_END 表示&quot;光标&quot;从文件末尾开始移动fseek(fp,0,SEEK_SET); &lt;---- 将光标定位到文件头fseek(fp,0,SEEK_END); &lt;---- 表示将光标定位到文件尾 12345678910111213141516int fscanf(FILE *stream, const char *format, ...);fscanf表示从指定的文件流stream中,按照format的格式获取输入数据, 并保存到...(参数列表)中给定的空间sscanf表示从指定的字符串str中,按照format的格式获取输入数据并保存到...(参数列表)中给定的空间int sscanf(const char *str, const char *format, ...);fprintf将参数列表中的数据,按format的格式输出到stream指定的流中int fprintf(FILE *stream, const char *format, ...); sprintf将参数列表中的数据,按format的格式输出到str指定的字符数组中int sprintf(char *str, const char *format, ...);str空间不足,可能导致存放不下输出的数据,从而很有可能在程序运行时出现&quot;段错误&quot; 为了改善这个bug,特引出了 snprintf snprintf表示将...中的数据以format的格式,最大输出size-1个字符到str中int snprintf(char *str, size_t size, const char *format, ...);]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F09%2F07%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[代码已写，待归纳参考：写给大家看的算法、218例 排序算法的判断指标： 稳定性稳 定：冒泡、插入、归并、基不稳定：选择、希尔、快速、堆保存相同的元素，经过排序后，相对位置不变。记忆规律：把原本的数组拆解的排序就不稳定。 空间复杂度：除了快速排序O(log2n)~O(N)都是O(1)时间复杂度：- 平均：shell特别，最快的归并和快速以及堆是O(nlog2n) 其他O(n2) - 最好：最快的不变，其他的O(n) 直接排序别管了！ - 最坏：快速排序变成大部分都是的O(n2) 最快最稳的还是归并啊！ 冒泡排序： 每次遍历，找到最大的放到后面，如何减小历遍的次数，两个循环。 缺点：慢，每次只能移动两个相邻的数据； 插入排序： 将后面的数据插入前面已经排列好的有序的数据中 缺点：比较次数不一定，比较次数越少，插入点后的数据移动越多，特别是数据量庞大的时候 归并排序: 将几个已排序的数据列，合并。 若n较大，并且要求排序稳定，则可以选择归并排序 选择排序： 多次遍历，一个for循环。区别冒泡 很垃圾 快速排序： 基准值 对比 根据基准值按照大小 左右分组 重复。 此排序算法的效率在序列越乱的时候，效率越高。在数据有序时，会退化成冒泡排序； 希尔排序： 拆分 插入排序 合并 比较在希尔排序中是最主要的操作，而不是交换。用已知最好的步长序列的希尔排序比直接插入排序要快，甚至在小数组中比快速排序和堆排序还快，但在涉及大量数据时希尔排序还是不如快排； 下面截取各个排序法的核心代码 12345678910选择排序：比我大就直接换位置for() //遍历数组 for() //遍历比较 if()//交换位置 &#123; t= --- =t &#125; 1234567冒泡排序：for()//趟数 for() //比较 if()//前后交换位置 &#123; &#125; 12345678910111213141516直接插入排序：把后面的未排序的数，插入到前面有序的数据中void insort(int s[],int a)&#123; int i,j; for(i=2;i&lt;=n;i++)//循环完成堆数组的遍历 &#123; s[0]=s[i];//s[0]起temp作用 j=i-1;//要比较元素的最左边的数据 while(s[0]&lt;s[j])//从后面开始比较，如果大于比较的数，就将其向后移动 &#123; s[j+1]=s[j]; j--;//从后向前比较 &#125; s[j+1]=s[0] &#125;&#125; 123456789101112131415161718192021222324希尔排序:把数据进行分组后再进行插入排序代码：在插入排序的基础上，增加一个分组的功能。插入排序是在一个数据列中移动，每个数据间隔为1希尔排序是在分组后的数据列中，每个数据间隔为d，将1改成d既可void insort(int s[],int a)&#123; int i,j,d; while(d&gt;=1) &#123; for(i=d+1;i&lt;=n;i++)//循环完成遍历 &#123; s[0]=s[i];//s[0]起temp作用 j=i-d;//要比较元素的最左边的数据 while(s[0]&lt;s[j])//从后面开始比较，如果大于比较的数，就将其向后移动 &#123; s[j+d]=s[j]; j=j-d;//从后向前比较 &#125; s[j+1]=s[0]; &#125; d=d/2; &#125;&#125; `快速排序：基准值 根据基准值分成左右分别大于和小于基准值的两组重复操作，使用递归完成。 代码分析：定义起点和终点，取起点为基准值，从终点开始扫描i&lt;j这个条件贯穿程序，因为只要i&gt;j说明数据被扫描完了。void qusort(int s[],int start,int end){ int i,j; i = start; j = end ; s[0]=s[start]; while(i&lt;j) { while(i&lt;j&amp;&amp;s[0]&lt;s[j])//从后面开始找到比基准小的值 j–； if(i&lt;j) { s[i]=s[j];//将小于基准值的数放到基准值的位置 i++;//+1开始 } while(i&lt;j&amp;&amp;s[i]&lt;=s[0]) i++;//从前面开始找到大于基准的数 if(i&lt;j) { s[j]=s[i];//将大于基准值的数放到之前找到的小于基准值的数的地方 j–;-1结束 节省时间！ } s[i]=s[0];//将基准值填入空出的s[i] if(start&lt;i) qusort(s,start,j-1); if(i&lt;end) qusort(s,j+1,end); } }]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018%2F09%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[常用链表模板栈与队列：熟悉树：熟悉遍历方法 链表单向链表双向链表循环链表 是什么？不是什么？和其他有什么异同？ 使用最多：双向循环链表创建链表： 结构体：存放数据和下一个指向 初始化链表 添加链表结点 附加 查、删、改结点 顺序排序typedef struct node{char path[128];//保存数据struct node next;//指向下一个struct node prev;//指向上一个}Node; typedef struct list{ Node first;//头节点 Node last;//尾节点}List; List init_link()//创建初始化链表{ List list = (List*) malloc(sizeof(List)); if(list == NULL) { perror(“List malloc error”); return NULL; } list-&gt;first = list-&gt;last = NULL; return list;} List add_link(List list,char filename,int mode){ 传进来了一个结点 将指向新创建的结点 Node p = (Node *)malloc(sizeof(Node));//新结点 if(p==NULL) { perror(“node malloc error”); return NULL; } p-&gt;mode=mode;//赋值给新结点 strcpy(p-&gt;path,filename);//字符串赋值 p-&gt;next = p-&gt;prev = NULL; if(list-&gt;first == NULL) { list-&gt;first = list-&gt;last = p; //头尾都是他 list-&gt;last-&gt;next = list-&gt;first; // 尾巴的下一个是 第一个 list-&gt;first-&gt;prev = list-&gt;last; } else { //尾插 list-&gt;last-&gt;next = p; // 原最后一个的下一个是新节点 p-&gt;prev = list-&gt;last;// list-&gt;last = p; //新节点成为新尾巴 list-&gt;last-&gt;next = list-&gt;first; //尾巴 的下一个是 第一个 list-&gt;first-&gt;prev = list-&gt;last; } return list; } 队列：限定在表头删除 表尾插入的线性表 称之为 队列！队头：指的是删除的那一端！队尾：插入的一端原则：先进先出 first in first out 栈：限定在表的一端进行插入和删除的线性表（stack）!栈顶：就是插入和删除的那一端！栈低：不能插入和删除的一端 树：前序遍历：根左右（1）访问根节点 （2）前序遍历左子树 （3）前序遍历右子树中序遍历：左根右（1）中序遍历左子树 （2）访问根节点 （3）中序遍历右子树后序遍历：左右根1）后序遍历左子树 （2）后序遍历右子树 （3）访问根节点核心理解：在子节点时也是按照规律输出，死守这个概念。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[结构体]]></title>
    <url>%2F2018%2F09%2F06%2F%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[其中: struct 结构体名 就是新的数据类型例如:12345678struct student&#123; int id; char name[50]; char sex[10]; int age; float score; &#125;; struct student stu;stu就是结构体变量名 结构体成员在内存中的分布以定义结构体时,成员定义的先后顺序依次分配空间定义的时候直接对变量赋值1) 按定义结构体的成员顺序,依次全初始化赋值,用’,’分开每一个变量的值 struct test t = {10086,’c’}; 2) 不按顺序赋值,需要指定赋值哪一个成员变量 struct test t = { .b = ‘c’, .a = 10010 }; 3) 结构体数组初始化 a.按数组元素依次初始化 struct test t[3] = { {1,’a’}, {2,’b’}, {3,’c’} };共用体与结构体的区别 结构体的大小 与 各成员变量的类型有关,是所有成员类型所占空间大小的和 还有字节对齐123456比如 struct test &#123; int a; int b; &#125;; ===&gt; 8个字节 共用体的所有成员共用一块内存空间,共用体的大小 就是成员中 内存空间最大的那个变量的空间大小12345678比如: union test &#123; int a; char c; short d; &#125;; ===&gt; 4字节======&gt; 共用体最大的特色 节约空间 b) 共用体中所有成员的地址 都是该成员中所占空间最大的那个变量的 首地址 共用体适用与 成员变量 不同时使用的情况 ===================================内存的存储模式=================================================在现代操作系统中,内存的存储分为 大端模式 和 小端模式 大端模式:数据的高字节存放在内存的低地址, 数据的低字节存放在内存的高地址 小端模式:数据的低字节存放在内存的低地址 数据的高字节存放在内存的高地址 验证当前系统的大小端;12345union test&#123; int a; char c;&#125;; t.a = 0x11223344;printf(“%x\n”,t.c) // 44 小端 11 大端1234567891011121314union test &#123; int a; char c[4]; &#125;; union test t; t.c[0] = 0x12; t.c[1] = 0x34; t.c[2] = 0x56; t.c[3] = 0x78; t.a == ? 0x12345678 //F 0x87654321 //F 0x78563412 //T 将枚举类型中的成员变量一一列举出在某些情况下,一个变量的值是在一定范围内变化的,那么我们就可以利用枚举,把该变量的值都列举出来比如:一个星期的变化是在 1 ~ 7之间12345678910enum weekday&#123; MON = 1, TUE, //2 WEN, //3 THU, //4 FRI, //5 SAT, //6 SUN //7&#125;; ★★★★★枚举可以在定义时给成员变量赋值,未赋值的成员变量由上一个变量的值 +1如果都未赋值,则第一个成员变量的值为 0, 后续变量依次+1 使用共同点和却别：struct testunion testenum test 模糊点：定义与声明 三者类似！定义： struct test{} union test{} enum test{}声明：许多方法 定义后声明123struct test name union test name enmu test name 2.定义时声明12enum week &#123; Mon=1, Tue, Wed, Thu, Fri Sat, Sun&#125; days; //变量days的类型为枚举型enum week 3.typedef设置别名123456789101112typedef enum workday&#123; saturday, sunday = 0, monday, tuesday, wednesday, thursday, friday&#125; workday; //此处的workday为枚举型enum workday的别名workday today, tomorrow; //变量today和tomorrow的类型为枚举型workday，也即enum workday]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[指针]]></title>
    <url>%2F2018%2F09%2F06%2F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[指针：其概念和地址是差不多的，可以认为地址就是一个指针 指针就是一个地址 指向运算符，当*和&amp;同时出现时可以抵消 int a = 5;int p = &a;如何通过 p给a赋值为6？ p = 6;一个变量的数据类型是什么？就是定义这个变量时 变量名前面的东西！ char b[10];char p = b;p所指向的内存空间中 的数据类型是什么？ charsizeof(p) = 1;偏移的单位就是1 int a[10];int q = a;q所指向的内存空间中 的数据类型是什么？intsizeof(q) = 4;偏移的单位是4！ p+i代表偏移i个单位长度 ，这个单位长度由p指向的数据类型来决定！12345678那么 将a当做一个数组来看 &amp;a 的含义是什么？整个数组的地址！整个数组的类型是什么？ int[10];&amp;a是一个地址其可以看做指向整个数组的常量指针！这个指针+1代表偏移1个单位长度 的地址 单位长度为sizeof(a) = 40！区分： a 数组名 其本质是标识整个数组！ 其值等于首地址 即&amp;a[0] 所以可以认为其是一个指向数组第0个元素的常量指针&amp;a[0] 数组第0个元素的地址 其值为首地址！&amp;a 取整个数组的地址 值为首地址！a &amp;a[0] &amp;a在值上等价 但是 在含以上相差甚远！ 数组指针和指针数组指针数组：数组 里面存储指针（字面对比理解：字符数组）int p[N]数组指针： 指针 指向一个数组（int型指针，这个就是数组型指针）int (p)[N];函数指针和指针函数指针函数：返回值类型为指针的函数 函数指针：指向函数的指针返回值类型 （*p）(参数列表类型)； const int p;代表const修饰指针指向的数据，指针的指向可以改变但是指针指向的内容不可以改变int const p;代表 const修饰指针 指针的指向不可改变 但是指针指向的内容可以变！const int *const p;指向和指向的值都不可以变！代表 const 修饰的是 a所指向的对象， 也就是 a可以变 但是a指向的地址中的值不可以变！ char c = ‘\0’;sizeof(c) = sizeof(typeof(c)) =sizeof(char) = 1sizeof(‘\0’) = sizeof(typeof(‘\0’)) = sizeof(typeof(0)) = sizeof(int) = 4原因：在计算机内存中 字符是以ASCII存放的！在计算机中参与运算的类型只有 int 和 double 有时会存在 float!参与运算是什么？ 整型运算一定当做int来运算然后类型隐式转化！123456789101112131415161718192021222324252627282930char *p = &quot;123456&quot;;sizeof(*p) = sizeof(typeof(*p)) = sizeof(char)=1sizeof(p) = sizeof(typeof(p)) = sizeof(char *) = 4int *p = NULL;sizeof(*p) = sizeof(typeof(*p)) = sizeof(int) = 4;sizeof(p) = sizeof(typeof(p)) = sizeof(int *) = 4;7、int a[10];int *p = a;sizeof(*p) = sizeof(typeof(*p)) =sizeof(int) = 4sizeof(p) = sizeof(typeof(p)) =sizeof(int *) = 48、int a[10];sizeof(a) = sizeof(typeof(a)) = sizeof(int [10]) = 40sizeof(&amp;a) = sizeof(typeof(&amp;a)) = sizeof(typeof(a)*) = sizeof(typeof(int[10])*) =sizeof(int* *) sizeof(int **) = 4sizeof(a[0]) = sizeof(typeof(a[0])) = sizeof(int) = 4sizeof(&amp;a[1]) = sizeof(typeof(&amp;a[1])) = sizeof(typeof(a[1])*) = sizeof(int *) = 4;9、short a = 5;sizeof(a) = 2;sizeof(&amp;a) = 4sizeof(a+1) = 4sizeof(a+1.0) = 810、int a[2][2];sizeof(a) = 16sizeof(a[0])= 8sizeof(a[0]+1)= 4sizeof(&amp;a[0]) = 4sizeof(*(*a[0]+1)) = sizeof(*(a[0][0]+1)) //这个表达式就是错的！ *a[0] =&gt;a[0][0] *(a[1]+2) = a[1][2]sizeof(a+1) = 4sizeof(*(a[0]+1)) = 4 简单理解二维数组与指针1234567891011121314151617181920212223242526272829int a[3][4] 含义 类型 数值a 整个数组 指针 tpyeof(a[0])* int[4]*ex：a+1 &amp;a[0] + 1 == &amp;a[1]a[0] 一维数组 指针 typeof(a[0][0])* int* ex：a[0]+1 &amp;a[0][0] + 1 == &amp;a[0][1]********&amp;a 指向一个 int[4][3]数组的指针 int[4][3]*&amp;a+1 指向a后的那个地址 X+48********&amp;a[0] 指针 int[4]*ex：&amp;a[0]+1 &amp;a[1]&amp;a[0][0] 一个地址 指针 typeof(a[0][0])*ex：&amp;a[0][0]+1 &amp;a[0][1]注意：*和&amp;同时出现就抵消 *(a+1) a[1]一维数组*(&amp;a[0]+1)*(&amp;a[1])(*(a+1)+2)+3*(a[1] +2)+3 a[1][2]+3*(&amp;a[1][0]+2)+3*(&amp;a[1][2])+3]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据间的运算规则]]></title>
    <url>%2F2018%2F09%2F05%2F%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[需要熟悉ascii：‘0’ 48 0x30‘a’ 97‘A’ 65比如:0x123456存储是:0000 0000 0001 0010 0011 0100 0101 0110 -1 存储在内存中是:0000 0000 0000 0000 0000 0000 0000 0001 (1)1111 1111 1111 1111 1111 1111 1111 1110 (~1)1111 1111 1111 1111 1111 1111 1111 1111 (~1 + 1 == -1) 1000 0000 0000 0000 0000 0000 0000 0000 这个就是最大的负数注意:内存中的数据是不存在符号位的,全都是数据位符号位只存在与编译器中 短型 —&gt; 长型 高字节补位短型有符号: 高字节补符号位短型无符号: 高字节补 0 有符号赋值给无符号数据遵守无符号数据默认比有符号数据范围大！char -128 - 127unsigned char 0-255最大数明显255 &gt; 127 所以认为无符号数据的表示范围大于 有符号数unsigned int a ;int b = -1;a = b;printf(“%d”,a); ＝&gt; -1 原因是 %d 打印有符号整型printf(“%u”,a); =&gt;0xFFFFFFFF;说明输出由编译器决定。 浮点常量并不是float 而是double输出格式： %[flags][width][.prec][F|N|h|l]type(最后才是类型） 浮点数据存储：N = (-1)^s 1.M 2^(E-偏置量）12345678910111213141516171819202122232425每一个数据对应的位类型 符号位s 阶码E 尾数 总位数 偏置量float 1 8 23 32 127double 1 11 52 64 1023``` 浮点数据如何转化为二进制数据：ex:float f = 12.4561、整数部分直接转化为二进制 12 = &gt; 11002、小数部分转化为二进制：拿小数部分乘以2依次取整数直到没有小数为止 0.456 =》.0111 0100 1011 1100 0011 0101 ........ 最多取23位即可3、将小数部分与整数部分整合 1100.0111 0100 1011 1100 0011 01014、移动小数点表示成1.M的形式 并记录移动了多少位 1.1000 1110 1001 0111 1000 0110 101 保留小数点后23位即可： 1.1000 1110 1001 0111 1000 011 左移了3位5、求阶码 在偏置量的基础上 加减 如果左移+ 位数 如果右移 -位数 E = 130 6、整合填充 s E M0 1000 0010 100 0 1110 1001 0111 1000 011将这个数据推回10进制 看看是多少？`-1^s x(1.尾数偏移（E-127,取出整数部分）)此时整数部分就是12尾数计算1100.01110 1001 0111 1000 01102^-1 +12^-2………….计算出的结果： 12.45599699039…并不是12.456 原因就是浮点数据的存储 有精度的损耗！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[输入输出函数]]></title>
    <url>%2F2018%2F09%2F05%2F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[scanf,gets,getchar的区别从标准输入流中读取内容。 scanf不会接收Space空格，回车符或空格或Tab还在缓冲区结束：回车Enter，Tab键 gets能接收空格键，缓冲区无残留结束：回车键，Tab键，回车则认为输入结束 getchar只能接受一个字符，可接受回车键。回车符或空格或Tab还在缓冲区结束：遇到回车结束输入 数据不是直接从外设得到，是先存入缓存区，遇到回车(\n)结束。注意：这个回车(\n)，也会存入缓存区，一般情况需要吸收！。 1），前面有scanf，后面要用ch=getchar()接收字符时，中间要用一个空的getchar（）吃回车； 2），2个接收字符的ch=getchar()中间需要一个空的getchar（）吃回车。include &lt;stdio.h&gt;printf/scanfprintf():123456789%d 打印10进制整型的 有符号%u 打印10进制整型的 无符号%c 打印一个字符%x 打印16进制数据%o 打印八进制数据%f 打印浮点数据%s 打印字符串的%p 打印地址的%g 打印时不输出无意义的0 scanf() 注意： scanf 的结束标志1、遇到非法字符 输入结束 比如 你要输入的是%d 一个整型而你输入了’n’ 就结束2、遇到空白符 比如 空格 回车 tab …..3、输入的宽度到了 就结束 比如 %3d 只能输入一个三位数 如果输入21345就结束了。强调： 在scanf输入中 格式化 怎么写就必须怎么输入 不能有任何不一致否则会出错对于初学者只建议使用占位符不要使用 其他符号。ex:int a,b,c,d;scanf(“%d %d %d %d\n”,&amp;a,&amp;b,&amp;c,&amp;d);输入时必须输入： ex： 1 2 3 4(回车)scanf(“%d%d%d%d”,&amp;a,&amp;b,&amp;c,&amp;d);输入只要以空白符作为间隔即可。 ex:1 2 3 4 (回车) ex:1 (回车)2 (回车)3 (回车)4 (回车)]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>printf和scanf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2018%2F08%2F27%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[解压：tar1234567891011总结*.tar 用 tar –xvf 解压*.gz 用 gzip -d或者gunzip 解压*.tar.gz和*.tgz 用 tar –xzf 解压*.bz2 用 bzip2 -d或者用bunzip2 解压*.tar.bz2用tar –xjf 解压*.Z 用 uncompress 解压*.tar.Z 用tar –xZf 解压*.rar 用 unrar e解压*.zip 用 unzip 解压一般带个v显示过程 1234567891011121314151617181920212223242526272829303132333435363738394041-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。-z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出下面的参数-f是必须的-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。# tar -cf all.tar *.jpg 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。# tar -rf all.tar *.gif 这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。# tar -uf all.tar logo.gif 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。# tar -tf all.tar 这条命令是列出all.tar包中所有文件，-t是列出文件的意思# tar -xf all.tar 这条命令是解出all.tar包中所有文件，-x是解开的意思压缩tar –cvf jpg.tar *.jpg 将目录里所有jpg文件打包成tar.jpgtar –czf jpg.tar.gz *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gztar –cjf jpg.tar.bz2 *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2tar –cZf jpg.tar.Z *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Zrar a jpg.rar *.jpg rar格式的压缩，需要先下载rar for linuxzip jpg.zip *.jpg zip格式的压缩，需要先下载zip for linux grep]]></content>
  </entry>
  <entry>
    <title><![CDATA[库的使用]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[jpeg图片显示使用了开源的库，编译时需要加-ljpeg这个就是动态库，还需将库放入开发板上，而编译时需要将jpeglib.h放到之前已经配置好的arm-linux-gcc 的那些文件夹bin：arm-linux。。。。。include：头文件lib：库share：似乎时man之类的说明文件]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>-使用库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环境配置]]></title>
    <url>%2F2018%2F08%2F23%2F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ubuntu配置交叉编译工具：压缩包：arm-2009q3.tar.bz2 /usr/local/目录下创建一个arm目录 1sudo mkdir /usr/local/arm 将arm-2009q3.tar.bz2解压到创建的目录中 1sudo tar -xvf arm-2009q3.tar.bz2 -C /usr/local/arm/ 将该目录下所有的交叉编译工具(一个一个？简便方法？),利用ln创建符号链接文件,以方便简写 1sudo ln -s arm-none-linux-gnueabi-gcc arm-linux-gcc 将交叉编译工具所在的路径添加到 PATH 1sudo vi /etc/profile 在文件末尾添加:1export PATH=$PATH:/usr/local/arm/arm-2009q3/bin 上述语句,添加到 /etc/profile中,重启后,整个系统有效添加到 ~/.profile中,重启后,当前要用户有效./bashrc和/etc/profile的区别 TFTP1234sudo apt-get install tftpd-hpasudo service tftpd-hpa startsudo service tftpd-hpa stopsudo service tftpd-hpa restart 123456sudo vi /etc/default/tftpd-hpa //配置文件TFTP_USERNAME=&quot;tftp&quot; //tftp服务的用户名 TFTP_DIRECTORY=&quot;/home/gec/tftp&quot; //文件只能在该目录中下载TFTP_ADDRESS=&quot;0.0.0.0:69&quot; // tftp服务器的地址和端口TFTP_OPTIONS=&quot;-l -c -s&quot; //tftp服务的选项,不用管照抄 开发板使用：12tftp -g -r filename tftp_server_addr //下载tftp -p -l filename tftp_server_addr //上传 -g get 获取文件-r 递归-p put 发送文件-l local 本地的 NFS1234sudo apt-get install nfs-kernel-server//服务端sudo apt install nfs-common //客户端sudo service nfs-kernel-server start// 启动这些服务均可使用：service + 服务(tab)可以补全 123sudo vim /etc/exports/home/csgec/nfs *(rw,sync,no_root_squash)//* 代表所有IP均可访问 配置好开发板和ubuntu的IP，开发板使用：mount ip:/home/csgec/nfs /mnt Sambahttps://blog.csdn.net/qq_33775402/article/details/79511339 Bash关于./bashrc的配置更新命令：source ？？？？ 隐藏绝对路径]]></content>
      <categories>
        <category>日积月累</category>
      </categories>
      <tags>
        <tag>交叉环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim]]></title>
    <url>%2F2018%2F08%2F23%2Fvim%2F</url>
    <content type="text"><![CDATA[map :call SaveInputData()func! SaveInputData() exec “tabnew” exec ‘normal “+gP’ exec “w! /tmp/input_data”endfunc “colorscheme torte“colorscheme murphy“colorscheme desert“colorscheme desert“colorscheme elflordcolorscheme ron “set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936“set termencoding=utf-8“set encoding=utf-8“set fileencodings=ucs-bom,utf-8,cp936“set fileencoding=utf-8 “”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ 显示相关“”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“set shortmess=atI “ 启动的时候不显示那个援助乌干达儿童的提示“winpos 5 5 “ 设定窗口位置“set lines=40 columns=155 “ 设定窗口大小set go= “ 不要图形按钮“color asmanian2 “ 设置背景主题“set guifont=Courier_New:h10:cANSI “ 设置字体“syntax on “ 语法高亮autocmd InsertLeave se nocul “ 用浅色高亮当前行autocmd InsertEnter se cul “ 用浅色高亮当前行“set ruler “ 显示标尺set showcmd “ 输入的命令显示出来，看的清楚些“set cmdheight=1 “ 命令行（在状态行下）的高度，设置为1“set whichwrap+=&lt;,&gt;,h,l “ 允许backspace和光标键跨越行边界(不建议)“set scrolloff=3 “ 光标移动到buffer的顶部和底部时保持3行距离set novisualbell “ 不要闪烁(不明白)set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\”%d/%m/%y\ -\ %H:%M\”)} “状态行显示的内容set laststatus=1 “ 启动显示状态行(1),总是显示状态行(2)set foldenable “ 允许折叠set foldmethod=manual “ 手动折叠“set background=dark “背景使用黑色set nocompatible “去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限“ 显示中文帮助if version &gt;= 603 set helplang=cn set encoding=utf-8endif“ 设置配色方案“colorscheme murphy“字体“if (has(“gui_running”))“ set guifont=Bitstream\ Vera\ Sans\ Mono\ 10“endif“””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“””””新文件标题“”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“新建.c,.h,.sh,.java文件，自动插入文件头autocmd BufNewFile .cpp,.[ch],.sh,.java exec “:call SetTitle()”“”定义函数SetTitle，自动插入文件头func SetTitle() “如果文件类型为.sh文件 if &amp;filetype == ‘sh’ call setline(1,”#########################################################################”) call append(line(“.”), “# File Name: “.expand(“%”)) call append(line(“.”)+1, “# Author: zxy”) call append(line(“.”)+2, “# mail: 310256030@qq.com“) call append(line(“.”)+3, “# Created Time: “.strftime(“%c”)) call append(line(“.”)+4, “#########################################################################”) call append(line(“.”)+5, “#!/bin/bash”) call append(line(“.”)+6, “”) else call setline(1, “/*“) call append(line(“.”), “ &gt; File Name: “.expand(“%”)) call append(line(“.”)+1, “ &gt; Author: zxy”) call append(line(“.”)+2, “ &gt; Mail: 310256030@qq.com“) call append(line(“.”)+3, “ &gt; Created Time: “.strftime(“%c”)) call append(line(“.”)+4, “ **/“) call append(line(“.”)+5, “”) endif if &amp;filetype == ‘cpp’ call append(line(“.”)+6, “#include“) call append(line(“.”)+7, “using namespace std;”) call append(line(“.”)+8, “”) endif if &amp;filetype == ‘c’ call append(line(“.”)+6, “#include&lt;stdio.h&gt;”) call append(line(“.”)+7, “”) call append(line(“.”)+8, “int main(void)”) call append(line(“.”)+9, “{“) call append(line(“.”)+10, “”) call append(line(“.”)+11, “ return 0;”) call append(line(“.”)+12, “}”) endif &quot; if &amp;filetype == &apos;java&apos; &quot; call append(line(&quot;.&quot;)+6,&quot;public class &quot;.expand(&quot;%&quot;)) &quot; call append(line(&quot;.&quot;)+7,&quot;&quot;) &quot; endif &quot;新建文件后，自动定位到文件末尾 autocmd BufNewFile * normal G endfunc“”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“键盘命令“””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””” nmap w :w!nmap f :find “ 映射全选+复制 ctrl+amap ggVGYmap! ggVGYmap gg=G“ 选中状态下 Ctrl+c 复制vmap “+y“去空行nnoremap :g/^\s*$/d“比较文件nnoremap :vert diffsplit“新建标签map :tabnew“列出当前目录文件map :tabnew .“打开树状文件目录map \be“C，C++ 按F5编译运行map :call CompileRunGcc()func! CompileRunGcc() exec “w” if &amp;filetype == ‘c’ exec “!g++ % -o %&lt;” exec “! ./%&lt;” elseif &amp;filetype == ‘cpp’ exec “!g++ % -o %&lt;” exec “! ./%&lt;” elseif &amp;filetype == ‘java’ exec “!javac %” exec “!java %&lt;” elseif &amp;filetype == ‘sh’ :!./% elseif &amp;filetype == ‘py’ exec “!python %” exec “!python %&lt;” endifendfunc“C,C++的调试map :call Rungdb()func! Rungdb() exec “w” exec “!g++ % -g -o %&lt;” exec “!gdb ./%&lt;”endfunc “”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“”实用设置“””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ 设置当文件被改动时自动载入set autoread“ quickfix模式autocmd FileType c,cpp map :w:make“代码补全set completeopt=preview,menu“允许插件filetype plugin on“共享剪贴板set clipboard+=unnamed“从不备份set nobackup“make 运行:set makeprg=g++\ -Wall\ \ %“自动保存set autowriteset ruler “ 打开状态栏标尺set cursorline “ 突出显示当前行set magic “ 设置魔术set guioptions-=T “ 隐藏工具栏set guioptions-=m “ 隐藏菜单栏“set statusline=\ %&lt;%F[%1%M%%n%R%H]%=\ %y\ %0(%{&amp;fileformat}\ %{&amp;encoding}\ %c:%l/%L%)\“ 设置在状态行显示的信息set foldcolumn=0set foldmethod=indentset foldlevel=3set foldenable “ 开始折叠“ 不要使用vi的键盘模式，而是vim自己的set nocompatible“ 语法高亮set syntax=on“ 去掉输入错误的提示声音set noeb“ 在处理未保存或只读文件的时候，弹出确认set confirm“ 自动缩进set autoindentset cindent“ Tab键的宽度set tabstop=4“ 统一缩进为4set softtabstop=4set shiftwidth=4“ 不要用空格代替制表符set noexpandtab“ 在行和段开始处使用制表符set smarttab“ 显示行号set number“ 历史记录数set history=1000“禁止生成临时文件set nobackupset noswapfile“搜索忽略大小写set ignorecase“搜索逐字符高亮set hlsearchset incsearch“行内替换set gdefault“编码设置set enc=utf-8set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936“语言设置set langmenu=zh_CN.UTF-8set helplang=cn“ 我的状态行显示的内容（包括文件类型和解码）“set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\”%d/%m/%y\ -\ %H:%M\”)}“set statusline=[%F]%y%r%m%%=[Line:%l/%L,Column:%c][%p%%]“ 总是显示状态行set laststatus=2“ 命令行（在状态行下）的高度，默认为1，这里是2set cmdheight=2“ 侦测文件类型filetype on“ 载入文件类型插件filetype plugin on“ 为特定文件类型载入相关缩进文件filetype indent on“ 保存全局变量set viminfo+=!“ 带有如下符号的单词不要被换行分割set iskeyword+=_,$,@,%,#,-“ 字符间插入的像素行数目set linespace=0“ 增强模式中的命令行自动完成操作set wildmenu“ 使回格键（backspace）正常处理indent, eol, start等set backspace=2“ 允许backspace和光标键跨越行边界set whichwrap+=&lt;,&gt;,h,l“ 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）set mouse=aset selection=exclusiveset selectmode=mouse,key“ 通过使用: commands命令，告诉我们文件的哪一行被改变过set report=0“ 在被分割的窗口间显示空白，便于阅读set fillchars=vert:\ ,stl:\ ,stlnc:\“ 高亮显示匹配的括号set showmatch“ 匹配括号高亮的时间（单位是十分之一秒）set matchtime=1“ 光标移动到buffer的顶部和底部时保持3行距离set scrolloff=3“ 为C程序提供自动缩进set smartindent“ 高亮显示普通txt文件（需要txt.vim脚本）au BufRead,BufNewFile setfiletype txt“自动补全:inoremap ( ()i:inoremap ) =ClosePair(‘)’)“:inoremap { {}O“:inoremap } =ClosePair(‘}’):inoremap [ []i:inoremap ] =ClosePair(‘]’):inoremap “ “”i:inoremap ‘ ‘’ifunction! ClosePair(char) if getline(‘.’)[col(‘.’) - 1] == a:char return “\“ else return a:char endifendfunctionfiletype plugin indent on“打开文件类型检测, 加了这句才可以用智能补全set completeopt=longest,menu“”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””” “NERDtee设定let NERDChristmasTree=1let NERDTreeAutoCenter=1let NERDTreeBookmarksFile=$VIM.’\Data\NerdBookmarks.txt’let NERDTreeMouseMode=2let NERDTreeShowBookmarks=1let NERDTreeShowFiles=1let NERDTreeShowHidden=1let NERDTreeShowLineNumbers=1let NERDTreeWinPos=’left’let NERDTreeWinSize=31nnoremap f :NERDTreeTogglemap :NERDTree]]></content>
      <categories>
        <category>日积月累</category>
      </categories>
      <tags>
        <tag>-vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译技巧]]></title>
    <url>%2F2018%2F08%2F23%2F%E7%BC%96%E8%AF%91%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[头文件编写使用头文件的目的就是说明函数实现的功能以及函数里各封装函数的作用，方便在主函数调用。注意：多文件编译时只有一个.c文件有main()，其他都是函数，供main()调用。 123#ifndef __宏__ //如果没有定义该宏,则执行下列语句直到endif,#define __宏__ //该宏为了防止同一头文件被重复定义#endif //结束标识 库库:是一种代码的二进制封装形式,直接可以使用库是封装好的代码,一般与头文件一起给需要的人，库的存在有利于程序的模块化,而且如果函数接口设置的合理,改变库的实现,不会影响用户使用。 动态库 在借助动态库编译程序时,程序只是记录需要的资源所在动态库中的位置，在运行程序时,再跳转到该位置去执行相应的功能。 如上所述,程序在执行时还需要依赖动态库因此用户在下载自己的程序时,还需要下载动态库,并设置LD_LIBRARY_PAHTk(一般开发板上是放置到/usr/lib)。 编辑源代码 name.c &lt;— 功能函数的实现 (产品) name.h &lt;— 函数及数据类型等的说明(说明书) 生成动态库： libname.so 12345678(arm-linux-)gcc -shared -fpic name.c(可以多个.c文件) -o libname.so其中:-shared 表示编译生成动态库-fpic 表示生成的动态库与位置无关name.c 表示要封装成库的 源文件（无main函数）libname.so lib库文件的前缀 .so 动态库的后缀 name 库的名字 带动态库的程序编译: 123456789(arm-linux-)gcc ***.c -o *** -Iincpath -Llibpath -llibname -Iincpath 指定头文件搜索路径 incpath -Llibpath 指定库文件搜索路径 libpath -llibname 指定库名 为libname例子：gec@ubuntu:库$ gcc main.c -o main -I. -L. -lsqstackgec@ubuntu:库$ ./main./main: error while loading shared libraries: libsqstack.so: cannot open shared object file: No such file or directorygec@ubuntu:库$ //错误:在使用动态库libsqstack.so时:不能打开库的文件:没有这个文件或目录 因此在程序运行前,要将使用的库所在的路径添加到 LD_LIBRARY_PATH 环境变量中(编辑/etc/profile ???)export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&lt;库所在目录的绝对路径&gt;也可以将库放到系统库的路径中 (/lib /usr/lib ….) 静态库: 在利用静态库编译程序时,程序会将静态库中的资源拷贝到自身程序中程序在运行时,就不需要静态库了，利用静态库编译的程序,往往会比较大。 编辑源代码 name.c &lt;— 功能函数的实现 (产品) name.h &lt;— 函数及数据类型等的说明(说明书) 生成静态库: libname.a 123(arm-linux-)gcc -c name.c -o name.o(arm-linux-)ar -rc libname.a name.o 编译静态库时,需要的文件是 中间文件(.o),因此在编译静态库前需要现将.c文件编成 .o 文件 带静态库编译 12345 (arm-linux-)gcc name.c -o -Iincpath -Llibpath -llibname -Iincpath 指定头文件搜索路径 incpath -Llibpath 指定库文件搜索路径 libpath -llibname 指定库名 为libname例子同上 利用静态库编译程序时,程序会将静态库中的资源全部拷贝到自身的程序文件中,直接下载程序就可以运行了,不需要下载库。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>头文件</tag>
        <tag>动态库</tag>
        <tag>静态库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单Hexo教程]]></title>
    <url>%2F2018%2F07%2F30%2F%E7%AE%80%E5%8D%95Hexo%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[目录：准备：github环境、github.io已配置好 安装Hexo 初次本地体验Hexo 配置Hexo 下载及配置Next主题 安装Hexo 安装node.js npm install -g hexo 使用环境的几条命令 部署：npm install hexo-deployer-git –save 初次本地体验Hexo 创建一个hexo文件夹保存内容 hexo init（initial：初始化） hexo g（generate：生成） hexo s （hexo server：启动本地服务预览） 复制出现的 http://localhost:4000 到浏览器可以看到效果 注意：如果电脑没有显示可能是端口被占用，使用hexo s -p 5000换个端口，网址的4000换成5000即可。 配置Hexo打开根目录下的_config.yml文件开始配置 界面：最上面可以找到title（标题）然后下面的都是可以写的，根据个人喜好配置。注意language可以用zh-Hans就可以显示中文。 主题：找到theme后面改成next，等下会配置此主题 开启搜索选项： npm install hexo-generator-searchdb –save 部署：配置好后方便后续的推送，找到deploy 格式如下 type: git repo: git@github.com:youname/yourname.github.io.git branch: master Hexo的简单配置完成 下载及配置Next主题 Next下载（在根目录下输入）:git clone https://github.com/iissnan/hexo-theme-next themes/next 简单配置 风格：找到Schemes Pisces不错，去掉前面的#使用 头像：在最后添加avatar: /images/yours.png 搜索选项：Local search enable改为true 新建和推送 新建：hexo new （布局–开头需要那些东西可以直接生成，在scaffolds文件夹中，我写了一个c.md）名字（生成.md文件，生成时间和标签头）例子：hexo new c 数据结构） 推送：hexo g(生成动态文件)—&gt;hexo s -p 5000(预览）—&gt;hexo deploy(部署）]]></content>
      <categories>
        <category>学习有感</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
