<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[环境配置]]></title>
    <url>%2F2018%2F08%2F23%2F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ubuntu配置交叉编译工具：压缩包：arm-2009q3.tar.bz2 /usr/local/目录下创建一个arm目录 1sudo mkdir /usr/local/arm 将arm-2009q3.tar.bz2解压到创建的目录中 1sudo tar -xvf arm-2009q3.tar.bz2 -C /usr/local/arm/ 将该目录下所有的交叉编译工具(一个一个？简便方法？),利用ln创建符号链接文件,以方便简写 1sudo ln -s arm-none-linux-gnueabi-gcc arm-linux-gcc 将交叉编译工具所在的路径添加到 PATH 1sudo vi /etc/profile 在文件末尾添加:1export PATH=$PATH:/usr/local/arm/arm-2009q3/bin 上述语句,添加到 /etc/profile中,重启后,整个系统有效添加到 ~/.profile中,重启后,当前要用户有效./bashrc和/etc/profile的区别 TFTP1234sudo apt-get install tftpd-hpasudo service tftpd-hpa startsudo service tftpd-hpa stopsudo service tftpd-hpa restart 123456sudo vi /etc/default/tftpd-hpa //配置文件TFTP_USERNAME=&quot;tftp&quot; //tftp服务的用户名 TFTP_DIRECTORY=&quot;/home/gec/tftp&quot; //文件只能在该目录中下载TFTP_ADDRESS=&quot;0.0.0.0:69&quot; // tftp服务器的地址和端口TFTP_OPTIONS=&quot;-l -c -s&quot; //tftp服务的选项,不用管照抄 开发板使用：12tftp -g -r filename tftp_server_addr //下载tftp -p -l filename tftp_server_addr //上传 -g get 获取文件-r 递归-p put 发送文件-l local 本地的 NFS1234sudo apt-get install nfs-kernel-server//服务端sudo apt install nfs-common //客户端sudo service nfs-kernel-server start// 启动这些服务均可使用：service + 服务(tab)可以补全 123sudo vim /etc/exports/home/csgec/nfs *(rw,sync,no_root_squash)//* 代表所有IP均可访问 配置好开发板和ubuntu的IP，开发板使用：mount ip:/home/csgec/nfs /mnt Sambahttps://blog.csdn.net/qq_33775402/article/details/79511339 Bash关于./bashrc的配置 隐藏绝对路径]]></content>
      <categories>
        <category>日积月累</category>
      </categories>
      <tags>
        <tag>交叉环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim]]></title>
    <url>%2F2018%2F08%2F23%2Fvim%2F</url>
    <content type="text"><![CDATA[map :call SaveInputData()func! SaveInputData() exec “tabnew” exec ‘normal “+gP’ exec “w! /tmp/input_data”endfunc “colorscheme torte“colorscheme murphy“colorscheme desert“colorscheme desert“colorscheme elflordcolorscheme ron “set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936“set termencoding=utf-8“set encoding=utf-8“set fileencodings=ucs-bom,utf-8,cp936“set fileencoding=utf-8 “”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ 显示相关“”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“set shortmess=atI “ 启动的时候不显示那个援助乌干达儿童的提示“winpos 5 5 “ 设定窗口位置“set lines=40 columns=155 “ 设定窗口大小set go= “ 不要图形按钮“color asmanian2 “ 设置背景主题“set guifont=Courier_New:h10:cANSI “ 设置字体“syntax on “ 语法高亮autocmd InsertLeave se nocul “ 用浅色高亮当前行autocmd InsertEnter se cul “ 用浅色高亮当前行“set ruler “ 显示标尺set showcmd “ 输入的命令显示出来，看的清楚些“set cmdheight=1 “ 命令行（在状态行下）的高度，设置为1“set whichwrap+=&lt;,&gt;,h,l “ 允许backspace和光标键跨越行边界(不建议)“set scrolloff=3 “ 光标移动到buffer的顶部和底部时保持3行距离set novisualbell “ 不要闪烁(不明白)set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\”%d/%m/%y\ -\ %H:%M\”)} “状态行显示的内容set laststatus=1 “ 启动显示状态行(1),总是显示状态行(2)set foldenable “ 允许折叠set foldmethod=manual “ 手动折叠“set background=dark “背景使用黑色set nocompatible “去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限“ 显示中文帮助if version &gt;= 603 set helplang=cn set encoding=utf-8endif“ 设置配色方案“colorscheme murphy“字体“if (has(“gui_running”))“ set guifont=Bitstream\ Vera\ Sans\ Mono\ 10“endif“””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“””””新文件标题“”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“新建.c,.h,.sh,.java文件，自动插入文件头autocmd BufNewFile .cpp,.[ch],.sh,.java exec “:call SetTitle()”“”定义函数SetTitle，自动插入文件头func SetTitle() “如果文件类型为.sh文件 if &amp;filetype == ‘sh’ call setline(1,”#########################################################################”) call append(line(“.”), “# File Name: “.expand(“%”)) call append(line(“.”)+1, “# Author: zxy”) call append(line(“.”)+2, “# mail: 310256030@qq.com“) call append(line(“.”)+3, “# Created Time: “.strftime(“%c”)) call append(line(“.”)+4, “#########################################################################”) call append(line(“.”)+5, “#!/bin/bash”) call append(line(“.”)+6, “”) else call setline(1, “/*“) call append(line(“.”), “ &gt; File Name: “.expand(“%”)) call append(line(“.”)+1, “ &gt; Author: zxy”) call append(line(“.”)+2, “ &gt; Mail: 310256030@qq.com“) call append(line(“.”)+3, “ &gt; Created Time: “.strftime(“%c”)) call append(line(“.”)+4, “ **/“) call append(line(“.”)+5, “”) endif if &amp;filetype == ‘cpp’ call append(line(“.”)+6, “#include“) call append(line(“.”)+7, “using namespace std;”) call append(line(“.”)+8, “”) endif if &amp;filetype == ‘c’ call append(line(“.”)+6, “#include&lt;stdio.h&gt;”) call append(line(“.”)+7, “”) call append(line(“.”)+8, “int main(void)”) call append(line(“.”)+9, “{“) call append(line(“.”)+10, “”) call append(line(“.”)+11, “ return 0;”) call append(line(“.”)+12, “}”) endif &quot; if &amp;filetype == &apos;java&apos; &quot; call append(line(&quot;.&quot;)+6,&quot;public class &quot;.expand(&quot;%&quot;)) &quot; call append(line(&quot;.&quot;)+7,&quot;&quot;) &quot; endif &quot;新建文件后，自动定位到文件末尾 autocmd BufNewFile * normal G endfunc“”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“键盘命令“””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””” nmap w :w!nmap f :find “ 映射全选+复制 ctrl+amap ggVGYmap! ggVGYmap gg=G“ 选中状态下 Ctrl+c 复制vmap “+y“去空行nnoremap :g/^\s*$/d“比较文件nnoremap :vert diffsplit“新建标签map :tabnew“列出当前目录文件map :tabnew .“打开树状文件目录map \be“C，C++ 按F5编译运行map :call CompileRunGcc()func! CompileRunGcc() exec “w” if &amp;filetype == ‘c’ exec “!g++ % -o %&lt;” exec “! ./%&lt;” elseif &amp;filetype == ‘cpp’ exec “!g++ % -o %&lt;” exec “! ./%&lt;” elseif &amp;filetype == ‘java’ exec “!javac %” exec “!java %&lt;” elseif &amp;filetype == ‘sh’ :!./% elseif &amp;filetype == ‘py’ exec “!python %” exec “!python %&lt;” endifendfunc“C,C++的调试map :call Rungdb()func! Rungdb() exec “w” exec “!g++ % -g -o %&lt;” exec “!gdb ./%&lt;”endfunc “”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“”实用设置“””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ 设置当文件被改动时自动载入set autoread“ quickfix模式autocmd FileType c,cpp map :w:make“代码补全set completeopt=preview,menu“允许插件filetype plugin on“共享剪贴板set clipboard+=unnamed“从不备份set nobackup“make 运行:set makeprg=g++\ -Wall\ \ %“自动保存set autowriteset ruler “ 打开状态栏标尺set cursorline “ 突出显示当前行set magic “ 设置魔术set guioptions-=T “ 隐藏工具栏set guioptions-=m “ 隐藏菜单栏“set statusline=\ %&lt;%F[%1%M%%n%R%H]%=\ %y\ %0(%{&amp;fileformat}\ %{&amp;encoding}\ %c:%l/%L%)\“ 设置在状态行显示的信息set foldcolumn=0set foldmethod=indentset foldlevel=3set foldenable “ 开始折叠“ 不要使用vi的键盘模式，而是vim自己的set nocompatible“ 语法高亮set syntax=on“ 去掉输入错误的提示声音set noeb“ 在处理未保存或只读文件的时候，弹出确认set confirm“ 自动缩进set autoindentset cindent“ Tab键的宽度set tabstop=4“ 统一缩进为4set softtabstop=4set shiftwidth=4“ 不要用空格代替制表符set noexpandtab“ 在行和段开始处使用制表符set smarttab“ 显示行号set number“ 历史记录数set history=1000“禁止生成临时文件set nobackupset noswapfile“搜索忽略大小写set ignorecase“搜索逐字符高亮set hlsearchset incsearch“行内替换set gdefault“编码设置set enc=utf-8set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936“语言设置set langmenu=zh_CN.UTF-8set helplang=cn“ 我的状态行显示的内容（包括文件类型和解码）“set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\”%d/%m/%y\ -\ %H:%M\”)}“set statusline=[%F]%y%r%m%%=[Line:%l/%L,Column:%c][%p%%]“ 总是显示状态行set laststatus=2“ 命令行（在状态行下）的高度，默认为1，这里是2set cmdheight=2“ 侦测文件类型filetype on“ 载入文件类型插件filetype plugin on“ 为特定文件类型载入相关缩进文件filetype indent on“ 保存全局变量set viminfo+=!“ 带有如下符号的单词不要被换行分割set iskeyword+=_,$,@,%,#,-“ 字符间插入的像素行数目set linespace=0“ 增强模式中的命令行自动完成操作set wildmenu“ 使回格键（backspace）正常处理indent, eol, start等set backspace=2“ 允许backspace和光标键跨越行边界set whichwrap+=&lt;,&gt;,h,l“ 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）set mouse=aset selection=exclusiveset selectmode=mouse,key“ 通过使用: commands命令，告诉我们文件的哪一行被改变过set report=0“ 在被分割的窗口间显示空白，便于阅读set fillchars=vert:\ ,stl:\ ,stlnc:\“ 高亮显示匹配的括号set showmatch“ 匹配括号高亮的时间（单位是十分之一秒）set matchtime=1“ 光标移动到buffer的顶部和底部时保持3行距离set scrolloff=3“ 为C程序提供自动缩进set smartindent“ 高亮显示普通txt文件（需要txt.vim脚本）au BufRead,BufNewFile setfiletype txt“自动补全:inoremap ( ()i:inoremap ) =ClosePair(‘)’)“:inoremap { {}O“:inoremap } =ClosePair(‘}’):inoremap [ []i:inoremap ] =ClosePair(‘]’):inoremap “ “”i:inoremap ‘ ‘’ifunction! ClosePair(char) if getline(‘.’)[col(‘.’) - 1] == a:char return “\“ else return a:char endifendfunctionfiletype plugin indent on“打开文件类型检测, 加了这句才可以用智能补全set completeopt=longest,menu“”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””” “NERDtee设定let NERDChristmasTree=1let NERDTreeAutoCenter=1let NERDTreeBookmarksFile=$VIM.’\Data\NerdBookmarks.txt’let NERDTreeMouseMode=2let NERDTreeShowBookmarks=1let NERDTreeShowFiles=1let NERDTreeShowHidden=1let NERDTreeShowLineNumbers=1let NERDTreeWinPos=’left’let NERDTreeWinSize=31nnoremap f :NERDTreeTogglemap :NERDTree]]></content>
      <categories>
        <category>日积月累</category>
      </categories>
      <tags>
        <tag>-vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译技巧]]></title>
    <url>%2F2018%2F08%2F23%2F%E7%BC%96%E8%AF%91%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[头文件编写使用头文件的目的就是说明函数实现的功能以及函数里各封装函数的作用，方便在主函数调用。注意：多文件编译时只有一个.c文件有main()，其他都是函数，供main()调用。 123#ifndef __宏__ //如果没有定义该宏,则执行下列语句直到endif,#define __宏__ //该宏为了防止同一头文件被重复定义#endif //结束标识 库库:是一种代码的二进制封装形式,直接可以使用库是封装好的代码,一般与头文件一起给需要的人，库的存在有利于程序的模块化,而且如果函数接口设置的合理,改变库的实现,不会影响用户使用。 动态库 在借助动态库编译程序时,程序只是记录需要的资源所在动态库中的位置，在运行程序时,再跳转到该位置去执行相应的功能。 如上所述,程序在执行时还需要依赖动态库因此用户在下载自己的程序时,还需要下载动态库,并设置LD_LIBRARY_PAHTk(一般开发板上是放置到/usr/lib)。 编辑源代码 name.c &lt;— 功能函数的实现 (产品) name.h &lt;— 函数及数据类型等的说明(说明书) 生成动态库： libname.so 12345678(arm-linux-)gcc -shared -fpic name.c(可以多个.c文件) -o libname.so其中:-shared 表示编译生成动态库-fpic 表示生成的动态库与位置无关name.c 表示要封装成库的 源文件（无main函数）libname.so lib库文件的前缀 .so 动态库的后缀 name 库的名字 带动态库的程序编译: 123456789(arm-linux-)gcc ***.c -o *** -Iincpath -Llibpath -llibname -Iincpath 指定头文件搜索路径 incpath -Llibpath 指定库文件搜索路径 libpath -llibname 指定库名 为libname例子：gec@ubuntu:库$ gcc main.c -o main -I. -L. -lsqstackgec@ubuntu:库$ ./main./main: error while loading shared libraries: libsqstack.so: cannot open shared object file: No such file or directorygec@ubuntu:库$ //错误:在使用动态库libsqstack.so时:不能打开库的文件:没有这个文件或目录 因此在程序运行前,要将使用的库所在的路径添加到 LD_LIBRARY_PATH 环境变量中(编辑/etc/profile ???)export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&lt;库所在目录的绝对路径&gt;也可以将库放到系统库的路径中 (/lib /usr/lib ….) 静态库: 在利用静态库编译程序时,程序会将静态库中的资源拷贝到自身程序中程序在运行时,就不需要静态库了，利用静态库编译的程序,往往会比较大。 编辑源代码 name.c &lt;— 功能函数的实现 (产品) name.h &lt;— 函数及数据类型等的说明(说明书) 生成静态库: libname.a 123(arm-linux-)gcc -c name.c -o name.o(arm-linux-)ar -rc libname.a name.o 编译静态库时,需要的文件是 中间文件(.o),因此在编译静态库前需要现将.c文件编成 .o 文件 带静态库编译 12345 (arm-linux-)gcc name.c -o -Iincpath -Llibpath -llibname -Iincpath 指定头文件搜索路径 incpath -Llibpath 指定库文件搜索路径 libpath -llibname 指定库名 为libname例子同上 利用静态库编译程序时,程序会将静态库中的资源全部拷贝到自身的程序文件中,直接下载程序就可以运行了,不需要下载库。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>头文件</tag>
        <tag>动态库</tag>
        <tag>静态库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[绝地求生之食物锦囊]]></title>
    <url>%2F2018%2F08%2F23%2F%E7%BB%9D%E5%9C%B0%E6%B1%82%E7%94%9F%E4%B9%8B%E9%A3%9F%E7%89%A9%E9%94%A6%E5%9B%8A%2F</url>
    <content type="text"><![CDATA[生活环境分析： 水源：教室有热水(早餐在寝室吃，中晚教室吃)食物候选：水果： 香蕉 苹果 主食： 全麦面包 红薯（不方便） 燕麦片 辅餐： 葡萄干（小包方便携带） 豆腐 酸奶]]></content>
      <categories>
        <category>绝地求生系列</category>
      </categories>
      <tags>
        <tag>食物</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单Hexo教程]]></title>
    <url>%2F2018%2F07%2F30%2F%E7%AE%80%E5%8D%95Hexo%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[目录：准备：github环境、github.io已配置好 安装Hexo 初次本地体验Hexo 配置Hexo 下载及配置Next主题 安装Hexo 安装node.js npm install -g hexo 使用环境的几条命令 部署：npm install hexo-deployer-git –save 初次本地体验Hexo 创建一个hexo文件夹保存内容 hexo init（initial：初始化） hexo g（generate：生成） hexo s （hexo server：启动本地服务预览） 复制出现的 http://localhost:4000 到浏览器可以看到效果 注意：如果电脑没有显示可能是端口被占用，使用hexo s -p 5000换个端口，网址的4000换成5000即可。 配置Hexo打开根目录下的_config.yml文件开始配置 界面：最上面可以找到title（标题）然后下面的都是可以写的，根据个人喜好配置。注意language可以用zh-Hans就可以显示中文。 主题：找到theme后面改成next，等下会配置此主题 开启搜索选项： npm install hexo-generator-searchdb –save 部署：配置好后方便后续的推送，找到deploy 格式如下 type: git repo: git@github.com:youname/yourname.github.io.git branch: master Hexo的简单配置完成 下载及配置Next主题 Next下载（在根目录下输入）:git clone https://github.com/iissnan/hexo-theme-next themes/next 简单配置 风格：找到Schemes Pisces不错，去掉前面的#使用 头像：在最后添加avatar: /images/yours.png 搜索选项：Local search enable改为true 新建和推送 新建：hexo new （布局–开头需要那些东西可以直接生成，在scaffolds文件夹中，我写了一个c.md）名字（生成.md文件，生成时间和标签头）例子：hexo new c 数据结构） 推送：hexo g(生成动态文件)—&gt;hexo s -p 5000(预览）—&gt;hexo deploy(部署）]]></content>
      <categories>
        <category>学习有感</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git+Hexo]]></title>
    <url>%2F2018%2F04%2F30%2FGit-Hexo%2F</url>
    <content type="text"><![CDATA[搭建前一直在看别人写的教程，就是不肯看官方的，觉得官方的教程肯定写的很难，很多软件也有自己的帮助和官方教程，但是我一般还是选择去查看别人的教程，总是觉得别人的写的就是通俗易懂，官方的就是难，大家搭建完后都喜欢给自己写个教程方便以后再次使用，但是写的时候会用自己能理解的语言去写，有时候他人难以理解。但是官方的教程争对的是所有需要安装的用户，其详细程度和易用性得到了众多用户的检验，根据自己的需求去参照官方教程其实是最节约时间的方法，而不要将时间浪费在阅读众多重复的个人教程上。]]></content>
      <categories>
        <category>学习有感</category>
      </categories>
  </entry>
</search>
