<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[字节对齐]]></title>
    <url>%2F2018%2F10%2F09%2F%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%2F</url>
    <content type="text"><![CDATA[http://www.cnblogs.com/clover-toeic/p/3853132.html12345678910struct A&#123; int a; char b; short c;&#125;;struct B&#123; char b; int a; short c;&#125;; sizeof(strcut A)值为8；sizeof(struct B)的值却是12 1) 结构体变量的首地址能够被其最宽基本类型成员的大小所整除； 2) 结构体每个成员相对结构体首地址的偏移量都是成员大小的整数倍，否则填充； 3) 结构体的总大小为结构体最宽基本类型成员大小的整数倍，否则填充； A = 4+1+1(根据条件2填充的)+2B = 1+3(根据条件2填充的)+4+2=10+2(根据条件3填充)]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[信号总结]]></title>
    <url>%2F2018%2F10%2F08%2F%E4%BF%A1%E5%8F%B7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Markdown语法]]></title>
    <url>%2F2018%2F09%2F13%2FMarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[注意：hexo中要注意空格 显示更多和代码展示1&lt;!-- more --&gt; 标题：注意空格一级标题二级标题三级标题四级标题五级标题六级标题强调斜体，_斜体_粗体，粗体加粗并斜体 删除线：这样来 删除一段文本 嵌套： 动物 水生动物陆生动物 猴子人 程序猿攻城狮产品狗 //这里需要注意，没有空行间隔，忽略降级引用标记射鸡虱 //这里需要注意，没有空行间隔，忽略降级引用标记 两栖类动物 大鳄鱼唐老鸭 两个回车结束引用,不在引用范围内了！ 表格： 列1 列2 列3 第1行 12 13 第2行 22 23 第3行 32 33 左对齐 右对齐 居中 Computer 5000 元 1台 Phone 1999 元 1部 链接：博客 标记作用：ctrl+a 引用： 你是？ 图片： 1234void main() &#123; printf(“Hello, Markdown.”); &#125; ONE ONE_ONR ONE_TWO TOW -列表展示 -列表展示 -列表展示]]></content>
  </entry>
  <entry>
    <title><![CDATA[线程]]></title>
    <url>%2F2018%2F09%2F13%2F%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[线程与进程的关系线程是一个进程的某个分支，一个进程至少应该有一个线程进程是操作系统分配资源的最小单元 线程是系统调度的最小单位！线程API函数1234567891011121314创建线程#include &lt;pthread.h&gt;int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);参数： thread 用于保存 线程号(需要创建) attr 创建线程的属性 一般默认属性填写 NULL void *(*start_routine) (void *) 函数指针 指针的名字start_routine 指向一个什么样的函数 一个返回 void* 指针 并有一个void*参数的函数！ 函数原型： void* 函数名（void *）; 指向线程的处理函数的指针！ arg 线程处理函数的参数！(需要会转换)返回值： 成功返回0 失败返回错误编码 即非0的数据 ！ 具体请解析！ 12345678910111213141516171819202122线程退出自杀 #include &lt;pthread.h&gt;void pthread_exit(void *retval);参数： 返回指针 作为线程函数的返回值 可以 pthread_jion接收！他杀 #include &lt;pthread.h&gt;int pthread_cancel(pthread_t thread);功能： 其实就是相当于一个线程给指定的线程发送一个“杀死”或“取消”信号 参数： thread 即指定的线程号 返回值： 成功返回0 失败返回错误码！0值 具体请解析注意： 线程收到这个信号并不一定会退出 这取决于线程的属性！int pthread_setcancelstate(int state, int *oldstate);功能： 设置线程取消的属性参数： state 要设置的属性 PTHREAD_CANCEL_ENABLE 可被别人取消 PTHREAD_CANCEL_DISABLE 不可被别人取消 oldstate 指定保存旧属性的变量的地址返回值： 成功返回0 失败返回错误码！0值 12345678910111213141516171819202122等待线程退出 #include &lt;pthread.h&gt;int pthread_join(pthread_t thread, void **retval);参数： thread 指定要等待那个线程退出 retval 二级指针 执行线程退出的值！ 也就是 pthread_exit 的参数 成功： 返回0 失败返回错误码！0值 注意： pthread_join 有两个作用： 第一个： 阻塞 直到等待的线程退出 第二个： 线程退出并不代表资源回收 其可以回收资源 这个取决于线程的一个属性： detach state 分离属性！ PTHREAD_CREATE_DETACHED : detach state 分离状态 他死了 资源自动释放 PTHREAD_CREATE_JOINABLE : joinable state 这种状态需要 该函数来回收资源 如果不指定则默认该状态！#include &lt;pthread.h&gt;int pthread_detach(pthread_t thread);功能： 将指定的线程设置为 detach 属性 参数：指定 线程的 id 返回值：成功返回0 失败返回错误码注意：如果线程已经处于分离状态再次设置分离状态 会导致状态不确定性 应禁止设置多次！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[共享内存和信号量]]></title>
    <url>%2F2018%2F09%2F13%2F%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%92%8C%E4%BF%A1%E5%8F%B7%E9%87%8F%2F</url>
    <content type="text"><![CDATA[123456789函数汇总： 消息队列 信号量： 共享内存头文件 &lt;sys/msg.h&gt; &lt;sys/sem.h&gt; &lt;sys/shm.h&gt;创建或打开IPC msgget() semget() shmget() ***get()控制IPC操作 msgctl() semctl() shmctl() ***ctlIPC操作函数 msgsnd/msgrcv semop shmat/shmdt 12345678910#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;key_t ftok(const char *pathname, int proj_id);功能：用来生成一个唯一的System V IPC对象的KEY!原理: 生成算法 是用一个已经存在的路径名 和一个整数组成和一个 key_t!参数： pathname 一个已经存在的路径 proj_id 一个整数标志返回值：成功返回一个 键！ 失败返回-1 同时 errno被设置！ ex: p1 与 p2 进行通信 则p1 与 p2 的钥匙要相同 如何做？ p1：key_t p1_key = ftok(“/home”,122);p2: key_t p2_key = ftok(“/home”,122);要保持一模一样！ 共享内存在内核或者设备内存中开辟一块空间进程A 可以将这块内存映射到自己的进程空间进程B 也可以将这段空间那么如果A 修改了 这个空间的内容，就对应的修改了B中的内容！映射： 形成一一对应的关系API函数1234567891011创建或者打开一个共享内存 #include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmget(key_t key, size_t size, int shmflg);参数： key: 获取的钥匙 size 共享内存的大小 shmflg 标志位 1、创建IPC_CREAT | 权限位 2、 0 打开 返回值： 成功返回共享内存的id 失败返回-1 错误被存放于errno 12345678910111213映射/解映射#include &lt;sys/types.h&gt;#include &lt;sys/shm.h&gt;void *shmat(int shmid, const void *shmaddr, int shmflg);参数： shmid:共享内存的id shmaddr NULL 由操作系统自行分配 shmflg 映射标志 1、SHM_RDONLY 只读映射 2、0 读写 返回值： 成功返回映射区域的首地址 失败返回 NULL 错误存放在 errnoint shmdt(const void *shmaddr);参数： 映射区域的首地址！ 12345678910对于共享内存的操作控制 #include &lt;sys/ipc.h&gt;#include &lt;sys/shm.h&gt;int shmctl(int shmid, int cmd, struct shmid_ds *buf);参数： shmid 共享内存id cmd 当 cmd == IPC_RMID 时写NULL返回值： 成功返回 0 失败返回-1 错误存放在errno ##信号量如果有两个或者两个以上的进程访问同一块共享资源（可以是硬件 也可以是软件）！并且这个资源的访问具有排他性 ，那么我们就需要保证这个资源访问的时候 是有序访问 否则会出现不可预知结果！ 进程中不同线程进行同步机制的一种手段！ API函数12345678910111213a、创建一个信号量#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;int semget(key_t key, int nsems, int semflg);参数： key : 获取的钥匙 nsems: 信号量的个数 如果不要创建信号量集只要打开 这个参数的值应该为0 一旦创建该值不可更改！ semflg: 标志 1、创建 IPC_CREAT | 权限位 2、打开 0 返回值： 成功返回信号量集的id,失败返回-1 错误存储在 errno 1234567891011121314151617181920212223242526b、信号量操作函数 #include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;int semctl(int semid, int semnum, int cmd, ...);参数： semid 信号量集的id semnum 要操作其中的那个信号量即数组下标 [0 - nsems-1] cmd： 操作指令 常用的有： GETVAL:获取第几个信号量的值 SETVAL:设置第几个信号量的值 GETALL:获取所有信号量的值 SETALL: 设置所有信号量的值 IPC_RMID 删除信号量 ... 拓展的参数 可有可无 具体与 cmd有关！ 当cmd == IPC_RMID 时 第四个参数不要 当cmd == GETVAL 时 第四个参数也不要 返回值就是这个信号量的值！ 当cmd == SETVAL 第四个参数就是我要设置的值 当cmd == GETALL 第四个参数就是要保存每个信号量的地址 即 ushrot arr[] 当cmd == SETALL 第四个参数 就是要设置每个信号量的值的数组名 当cmd == IPC_SET 即设置这个信号量的属性 则第四个参数就是 struct semid_ds 的指针！ 当cmd == IPC_STAT 即获取这个信号量的属性 第四个参数表示将属性存放在这个地址中！ 返回值： 具体情况具体分析 12345678910111213141516171819202122232425262728c、PV 操作PV 操作是使用一个结构体(这个结构体包含在头文件中，定义一个结构体变量即可)来实现选择#include &lt;sys/types.h&gt;#include &lt;sys/ipc.h&gt;#include &lt;sys/sem.h&gt;struct sembuf&#123; unsigned short sem_num; /* semaphore number */ 指哪一个信号量 short sem_op; /* semaphore operation */ 信号量的操作 是一个 有符号的short类型 即做了相关操作后 semval = 原semval + sem_op sem_op &gt;0 表示 V 操作 一般会置为 +1 ！ ste_op &lt;0 表示 P操作 一般会置为 -1 ste_op ==0 自己尝试 看看是否就会阻塞！ short sem_flg; /* operation flags */ 操作标志： 0 表示默认 IPC_NOWAIT 非阻塞 如果是P操作 信号量没有获取到则直接走人 返回-1 表示不能获取！ SEM_UNDO 撤销 这个标志意义重大！ 为了防止进程带锁退出 如果设置了这个标志 内核会额外的记录该进程的PV 操作 当进程退出时 会还原！&#125;int semop(int semid, struct sembuf *sops, unsigned nsops);参数： semid 信号量集id sops: 操作选择的结构体指针 nsops:对几个信号量进行PV 表示有多少个信号量进行PV 操作 一般写一个1 ！返回值：成功返回0 失败返回-1 P操作和v操作如果一个进程需要等待即获取信号量，那么将会测试这个信号量的值 如果其值大于0 则信号量的值 -1该进程就会去访问这个资源，如果该信号量的值 等于0 那么这个进程将会阻塞等待信号量的到来！这就是信号量所说的 P操作 即Proberen 尝试！如果是互斥信号量 即互斥锁 就叫做 lock上锁！释放一个信号量如果一个进程使用完共享资源就需要释放 ，释放一个信号量时 如果当前有进程因等待信号量而被阻塞 那么其第一个将会恢复执行来访问资源，如果没有进程因等待而阻塞 那么信号量的值将+1这就是信号量中所说的 V操作 即 Verhogen 增加如果是互斥信号量 即互斥锁 就叫做 unlock 解锁]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[typedef]]></title>
    <url>%2F2018%2F09%2F11%2Ftypedef%2F</url>
    <content type="text"><![CDATA[define Type_D inttypedef int Type_T使用上述两个类型分别定义了两个变量Type_D a,b;Type_T x,y; 请问 a b x y分别是什么类型，使用 #define 与 typeof的区别是什么？那个更加好？typeof(a) = int*typeof(b) = int define 是字符替换int a,b; =&gt; int a,b; *号结合性！ typeof(x) = inttypeof(y) = int（int*） x,y;//但是语法不支持 编译不会过 C语言不可以给类型加()?注意：(类型说明符) 这是类型强转！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[fork经典]]></title>
    <url>%2F2018%2F09%2F11%2Ffork%E7%BB%8F%E5%85%B8%2F</url>
    <content type="text"><![CDATA[小收获：The Design of Everyday Thingsenv:Linux查看环境变量使用env命令显示所有的环境变量产生多少main？int main(int argc, char *argv[]) { fork(); fork() &amp;&amp; fork() || fork(); fork(); }解析总结：fork一次产生一个新进程，父进程一直跟随20个计算法：fork一次就加1 这里注意最后一个fork最后也会执行，第二行代码执行后最后一个fork也会执行 int main(void){ int i; for(i=0;i&lt;2;i++) { fork(); printf(“_\n”); } return 0;}答案：6 int main(void){ int i; for(i=0;i&lt;2;i++) { fork(); printf(““); } return 0;}答案：8这两题一样，这里先算出最后有多少进程，然后算出产生这些进程的过程。这里就是 2—&gt; 4 2+4=6注意：不带\n有两个会在缓冲区 因此会增加数量]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据存储空间]]></title>
    <url>%2F2018%2F09%2F11%2F%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%A9%BA%E9%97%B4%2F</url>
    <content type="text"><![CDATA[程序在运行过程中,数据的存储问题Linux将程序运行时,地址空间分为了6个部分 栈: 用来存放局部变量(未初始化) 生成周期 随函数(代码块)持续性堆: 用来存放动态分配的空间 malloc/realloc/calloc三个函数都是用来动态分配存储空间,并且返回分配的空间的首地址 生存周期,只要没有释放(free),那么随进程持续性 .bss: 用来存放未初始化的全局变量和未初始化的 static修饰的变量 随进程持续性:程序运行时就分配空间,程序结束时才回收(销毁.释放)空间 .rodata read ONLY data 用来存放只读数据 比如 常量 随进程持续性 .data 数据段 存放初始化的局部变量和初始化的static修饰的变量 随进程持续性 .text 文本 文本段,用来存放代码/指令 也被称为 代码段 随进程持续性]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[文档要求]]></title>
    <url>%2F2018%2F09%2F11%2F%E6%96%87%E6%A1%A3%E8%A6%81%E6%B1%82%2F</url>
    <content type="text"><![CDATA[如何做笔记？ 函数使用： 头文件 参数、说明 使用例子(贴代码) 特殊情况 2.编写代码时函数描述：12345678910111213/************************************************* Function: // 函数名称 Description: // 函数功能、性能等的描述 Calls: // 被本函数调用的函数清单 Called By: // 调用本函数的函数清单 Table Accessed: // 被访问的表（此项仅对于牵扯到数据库操作的程序） Table Updated: // 被修改的表（此项仅对于牵扯到数据库操作的程序） Input: // 输入参数说明，包括每个参数的作 // 用、取值说明及参数间关系。 Output: // 对输出参数的说明。 Return: // 函数返回值的说明 Others: // 其它说明*************************************************/ 3.用正确的反义词组命名具有互斥意义的变量或相反动作的函数:1add / remove begin / end create / destroy insert / delete first / last get / release increment / decrement put / get add / delete lock / unlock open / close min / max old / new start / stop next / previous source / target show / hide send / receive source / destination cut / paste up / down 4.编写代码说明：123456789/************************************************* Copyright (C), 1988-1999, Huawei Tech. Co., Ltd. File name: // 文件名 Author: Version: Date: // 作者、版本及完成日期 Description: // 用于详细说明此程序文件完成的主要功能，与其他块 // 或函数的接口，输出值、取值范围、含义及参数间的控 // 制、顺序、独立或依赖等关系 Others: // 其它内容的说明 Function List: // 主要函数列表，每条记录应包括函数名及功能简要说明]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>文档规范</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim技巧]]></title>
    <url>%2F2018%2F09%2F10%2Fvim%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[留下坑，慢慢填1. 标签页和多窗口2.]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[链接保存]]></title>
    <url>%2F2018%2F09%2F10%2F%E9%93%BE%E6%8E%A5%E4%BF%9D%E5%AD%98%2F</url>
    <content type="text"><![CDATA[arduino极客工坊项目实验室数据结构和算法排序算法参考 书籍保存 linux 递归一下 嵌入式学习网站守望者:什么都有点 linux别人的blog 嵌入式别人的blog LINUX什么都有点 嵌入式别人的blog2 51cto 吴川斌 左耳朵耗子 他人资料整理1 他人资料整理2 二次元程序员 github教程https://git-scm.com/book/zh/v2/ https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000 成为理想程序员 C语言资料大全 grub使用教程http://wiki.ubuntu.org.cn/GRUB%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B ALL in one:make a kinds of sys boot from U盘https://www.aioboot.com/en/how-to-use/ 字节对齐 别出心裁Linux命令 cheat 极品飞车]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[信号]]></title>
    <url>%2F2018%2F09%2F07%2F%E4%BF%A1%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[常见信号12345678910111213141516171819202122SIGHUP 1 Term Hangup detected on controlling terminal or death of controlling process 在控制终端收到一个&quot;挂起&quot;或控制进程死亡时会收到该信号 SIGINT 2 Term Interrupt from keyboard 终止进程运行CTRL+C SIGQUIT 3 Core Quit from keyboard 发送停止信息并停止进程执行 CTRL+Z SIGILL 4 Core Illegal Instruction 遇到非法指令时产生的信号 SIGABRT 6 Core Abort signal from abort(3) 进程非正常终止时产生的信号 SIGFPE 8 Core Floating point exception 遇到一个浮点错误 a/0 SIGKILL 9 Term Kill signal 杀死进程 SIGSEGV 11 Core Invalid memory reference 非法内存引用(段错误) SIGPIPE 13 Term Broken pipe: write to pipe with no readers当管道写端写入数据时,管道读端收到该信号 SIGALRM 14 Term Timer signal from alarm(2) 定时器信号,超时信号 SIGTERM 15 Term Termination signal 终止信号 CTRL+\ SIGUSR1 30,10,16 Term User-defined signal 1 用户自定义信号1 SIGUSR2 31,12,17 Term User-defined signal 2 用户自定义信号2 SIGCHLD 20,17,18 Ign Child stopped or terminated子进程退出时,父进程收到该信号 SIGCONT 19,18,25 Cont Continue if stopped 继续执行一个挂起的进程 SIGSTOP 17,19,23 Stop Stop process 停止一个进程 SIGTSTP 18,20,24 Stop Stop typed at terminal 从终端上发起停止信号 SIGTTIN 21,21,26 Stop Terminal input for background process 后台试图从控制台输入 SIGTTOU 22,22,27 Stop Terminal output for background process 后台试图从控制台输出 12345678910111213141516171819202122232425262728293031323334353637#include&lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;signal.h&gt;typedef void (*sighandler_t)(int);int flg = 1;void my_sig_fun(int sig)&#123; printf(&quot;recv signal is:%d\n&quot;,sig); switch(sig) &#123; case SIGINT: printf(&quot;I can go out\n&quot;); flg = 0; break; case SIGALRM: printf(&quot;time out\n&quot;); flg = 0; break; &#125;&#125;int main(int argc,char *argv[])&#123; signal(SIGINT,my_sig_fun); signal(SIGALRM,my_sig_fun); alarm(5); //kill(atoi(argv[1]),SIGKILL);//atoi函数,是用来将给定的数字字符串转换为整数 while(flg) &#123; printf(&quot;zhuan bei shang!!\n&quot;); sleep(1); &#125; return 0;&#125;]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[系统io]]></title>
    <url>%2F2018%2F09%2F07%2F%E7%B3%BB%E7%BB%9Fio%2F</url>
    <content type="text"><![CDATA[openreadcloselseek：定位opendirreddir例子：bmp显示 目录读取（见项目电子相册）]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[标准io]]></title>
    <url>%2F2018%2F09%2F07%2F%E6%A0%87%E5%87%86io%2F</url>
    <content type="text"><![CDATA[需要：#include &lt;stdio.hFILE f1,f2;f1 = fopen(“./1.txt”,”r”);fclose(f1);12345678910111213141516171819202122a. 按字节读写:每次读写一个字节 getc/fgetc/getcharint getc(FILE *stream);int fgetc(FILE *stream);int getchar(void); putc/fputc/putcharint putchar(int c);int fputc(int c, FILE *stream);int putc(int c, FILE *stream); b. 按行读写: 每次读写一行数据 gets/fgetschar *gets(char *s);char *fgets(char *s, int size, FILE *stream); puts/fputs c. 直接读写: 每次按开发者需求进行读写 fread fwritesize_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);size_t fwrite(const void *ptr, size_t size, size_t nmemb,FILE *stream);对于读写流来说,读写位置由光标决定: 读是读取光标所在位置的内容 写是写入光标所在的位置 每次读写后光标自动后移n个字节(n是读写的字节数) 1234567定位int fseek(FILE *stream, long offset, int whence);SEEK_SET 表示&quot;光标&quot;相对于 文件头移动SEEK_CUR 表示&quot;光标&quot;从当前位置移动SEEK_END 表示&quot;光标&quot;从文件末尾开始移动fseek(fp,0,SEEK_SET); &lt;---- 将光标定位到文件头fseek(fp,0,SEEK_END); &lt;---- 表示将光标定位到文件尾 12345678910111213141516int fscanf(FILE *stream, const char *format, ...);fscanf表示从指定的文件流stream中,按照format的格式获取输入数据, 并保存到...(参数列表)中给定的空间sscanf表示从指定的字符串str中,按照format的格式获取输入数据并保存到...(参数列表)中给定的空间int sscanf(const char *str, const char *format, ...);fprintf将参数列表中的数据,按format的格式输出到stream指定的流中int fprintf(FILE *stream, const char *format, ...); sprintf将参数列表中的数据,按format的格式输出到str指定的字符数组中int sprintf(char *str, const char *format, ...);str空间不足,可能导致存放不下输出的数据,从而很有可能在程序运行时出现&quot;段错误&quot; 为了改善这个bug,特引出了 snprintf snprintf表示将...中的数据以format的格式,最大输出size-1个字符到str中int snprintf(char *str, size_t size, const char *format, ...);]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2018%2F09%2F07%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[代码已写，待归纳参考：写给大家看的算法、218例冒泡排序：快速排序：递归排序:选择排序：希尔排序：选择排序：]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2018%2F09%2F07%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[常用链表模板栈与队列：熟悉树：熟悉遍历方法 链表单向链表双向链表循环链表 使用最多：双向循环链表创建链表： 结构体：存放数据的下一个指向 初始化链表 添加链表结点 附加 查、删、改结点 顺序排序typedef struct node{char path[128];int mode;struct node next;struct node prev;}Node; typedef struct list{ Node first; Node last;}List; List init_link()//创建初始化链表{ List list = (List*) malloc(sizeof(List)); if(list == NULL) { perror(“List malloc error”); return NULL; } list-&gt;first = list-&gt;last = NULL; return list;} List add_link(List list,char filename,int mode){ Node p = (Node *)malloc(sizeof(Node)); if(p==NULL) { perror(“node malloc error”); return NULL; } p-&gt;mode=mode; strcpy(p-&gt;path,filename); p-&gt;next = p-&gt;prev = NULL; if(list-&gt;first == NULL) { list-&gt;first = list-&gt;last = p; //头尾都是他 list-&gt;last-&gt;next = list-&gt;first; // 尾巴的下一个是 第一个 list-&gt;first-&gt;prev = list-&gt;last; } else { //尾插 list-&gt;last-&gt;next = p; // 原最后一个的下一个是新节点 p-&gt;prev = list-&gt;last;// list-&gt;last = p; //新节点成为新尾巴 list-&gt;last-&gt;next = list-&gt;first; //尾巴 的下一个是 第一个 list-&gt;first-&gt;prev = list-&gt;last; } return list; } 队列：限定在表头删除 表尾插入的线性表 称之为 队列！队头：指的是删除的那一端！队尾：插入的一端原则：先进先出 first in first out 栈：限定在表的一端进行插入和删除的线性表（stack）!栈顶：就是插入和删除的那一端！栈低：不能插入和删除的一端 树：前序遍历：根左右（1）访问根节点 （2）前序遍历左子树 （3）前序遍历右子树中序遍历：左根右（1）中序遍历左子树 （2）访问根节点 （3）中序遍历右子树后序遍历：左右根1）后序遍历左子树 （2）后序遍历右子树 （3）访问根节点核心理解：在子节点时也是按照规律输出，套用嵌套的概念。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[结构体]]></title>
    <url>%2F2018%2F09%2F06%2F%E7%BB%93%E6%9E%84%E4%BD%93%2F</url>
    <content type="text"><![CDATA[其中: struct 结构体名 就是新的数据类型例如:12345678struct student&#123; int id; char name[50]; char sex[10]; int age; float score; &#125;; struct student stu;stu就是结构体变量名 结构体成员在内存中的分布以定义结构体时,成员定义的先后顺序依次分配空间定义的时候直接对变量赋值1) 按定义结构体的成员顺序,依次全初始化赋值,用’,’分开每一个变量的值 struct test t = {10086,’c’}; 2) 不按顺序赋值,需要指定赋值哪一个成员变量 struct test t = { .b = ‘c’, .a = 10010 }; 3) 结构体数组初始化 a.按数组元素依次初始化 struct test t[3] = { {1,’a’}, {2,’b’}, {3,’c’} };共用体与结构体的区别a)结构体的大小 与 各成员变量的类型有关,是所有成员类型所占空间大小的和123456比如 struct test &#123; int a; int b; &#125;; ===&gt; 8个字节 共用体的所有成员共用一块内存空间,共用体的大小 就是成员中 内存空间最大的那个变量的空间大小12345678比如: union test &#123; int a; char c; short d; &#125;; ===&gt; 4字节======&gt; 共用体最大的特色 节约空间 b) 共用体中所有成员的地址 都是该成员中所占空间最大的那个变量的 首地址 共用体适用与 成员变量 不同时使用的情况 ===================================内存的存储模式=================================================在现代操作系统中,内存的存储分为 大端模式 和 小端模式 大端模式:数据的高字节存放在内存的低地址, 数据的低字节存放在内存的高地址 小端模式:数据的低字节存放在内存的低地址 数据的高字节存放在内存的高地址 验证当前系统的大小端;12345union test&#123; int a; char c;&#125;; t.a = 0x11223344;printf(“%x\n”,t.c) // 44 小端 11 大端1234567891011121314union test &#123; int a; char c[4]; &#125;; union test t; t.c[0] = 0x12; t.c[1] = 0x34; t.c[2] = 0x56; t.c[3] = 0x78; t.a == ? 0x12345678 //F 0x87654321 //F 0x78563412 //T 将枚举类型中的成员变量一一列举出在某些情况下,一个变量的值是在一定范围内变化的,那么我们就可以利用枚举,把该变量的值都列举出来比如:一个星期的变化是在 1 ~ 7之间12345678910enum weekday&#123; MON = 1, TUE, //2 WEN, //3 THU, //4 FRI, //5 SAT, //6 SUN //7&#125;; ★★★★★枚举可以在定义时给成员变量赋值,未赋值的成员变量由上一个变量的值 +1如果都未赋值,则第一个成员变量的值为 0, 后续变量依次+1]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[指针]]></title>
    <url>%2F2018%2F09%2F06%2F%E6%8C%87%E9%92%88%2F</url>
    <content type="text"><![CDATA[指针：其概念和地址是差不多的，可以认为地址就是一个指针 指针就是一个地址 指向运算符，当*和&amp;同时出现时可以抵消 int a = 5;int p = &a;如何通过 p给a赋值为6？ p = 6;一个变量的数据类型是什么？就是定义这个变量时 变量名前面的东西！ char b[10];char p = b;p所指向的内存空间中 的数据类型是什么？ charsizeof(p) = 1;偏移的单位就是1 int a[10];int q = a;q所指向的内存空间中 的数据类型是什么？intsizeof(q) = 4;偏移的单位是4！ p+i代表偏移i个单位长度 ，这个单位长度由p指向的数据类型来决定！12345678那么 将a当做一个数组来看 &amp;a 的含义是什么？整个数组的地址！整个数组的类型是什么？ int[10];&amp;a是一个地址其可以看做指向整个数组的常量指针！这个指针+1代表偏移1个单位长度 的地址 单位长度为sizeof(a) = 40！区分： a 数组名 其本质是标识整个数组！ 其值等于首地址 即&amp;a[0] 所以可以认为其是一个指向数组第0个元素的常量指针&amp;a[0] 数组第0个元素的地址 其值为首地址！&amp;a 取整个数组的地址 值为首地址！a &amp;a[0] &amp;a在值上等价 但是 在含以上相差甚远！ 数组指针和指针数组指针数组：数组 里面存储指针（字面对比理解：字符数组）int p[N]数组指针： 指针 指向一个数组（int型指针，这个就是数组型指针）int (p)[N];函数指针和指针函数指针函数：返回值类型为指针的函数 函数指针：指向函数的指针返回值类型 （*p）(参数列表类型)； const int p;代表const修饰指针指向的数据，指针的指向可以改变但是指针指向的内容不可以改变int const p;代表 const修饰指针 指针的指向不可改变 但是指针指向的内容可以变！const int *const p;指向和指向的值都不可以变！代表 const 修饰的是 a所指向的对象， 也就是 a可以变 但是a指向的地址中的值不可以变！ char c = ‘\0’;sizeof(c) = sizeof(typeof(c)) =sizeof(char) = 1sizeof(‘\0’) = sizeof(typeof(‘\0’)) = sizeof(typeof(0)) = sizeof(int) = 4原因：在计算机内存中 字符是以ASCII存放的！在计算机中参与运算的类型只有 int 和 double 有时会存在 float!参与运算是什么？ 整型运算一定当做int来运算然后类型隐式转化！123456789101112131415161718192021222324252627282930char *p = &quot;123456&quot;;sizeof(*p) = sizeof(typeof(*p)) = sizeof(char)=1sizeof(p) = sizeof(typeof(p)) = sizeof(char *) = 4int *p = NULL;sizeof(*p) = sizeof(typeof(*p)) = sizeof(int) = 4;sizeof(p) = sizeof(typeof(p)) = sizeof(int *) = 4;7、int a[10];int *p = a;sizeof(*p) = sizeof(typeof(*p)) =sizeof(int) = 4sizeof(p) = sizeof(typeof(p)) =sizeof(int *) = 48、int a[10];sizeof(a) = sizeof(typeof(a)) = sizeof(int [10]) = 40sizeof(&amp;a) = sizeof(typeof(&amp;a)) = sizeof(typeof(a)*) = sizeof(typeof(int[10])*) =sizeof(int* *) sizeof(int **) = 4sizeof(a[0]) = sizeof(typeof(a[0])) = sizeof(int) = 4sizeof(&amp;a[1]) = sizeof(typeof(&amp;a[1])) = sizeof(typeof(a[1])*) = sizeof(int *) = 4;9、short a = 5;sizeof(a) = 2;sizeof(&amp;a) = 4sizeof(a+1) = 4sizeof(a+1.0) = 810、int a[2][2];sizeof(a) = 16sizeof(a[0])= 8sizeof(a[0]+1)= 4sizeof(&amp;a[0]) = 4sizeof(*(*a[0]+1)) = sizeof(*(a[0][0]+1)) //这个表达式就是错的！ *a[0] =&gt;a[0][0] *(a[1]+2) = a[1][2]sizeof(a+1) = 4sizeof(*(a[0]+1)) = 4 简单理解二维数组与指针1234567891011121314151617181920212223242526272829int a[3][4] 含义 类型 数值a 整个数组 指针 tpyeof(a[0])* int[4]*ex：a+1 &amp;a[0] + 1 == &amp;a[1]a[0] 一维数组 指针 typeof(a[0][0])* int* ex：a[0]+1 &amp;a[0][0] + 1 == &amp;a[0][1]********&amp;a 指向一个 int[4][3]数组的指针 int[4][3]*&amp;a+1 指向a后的那个地址 X+48********&amp;a[0] 指针 int[4]*ex：&amp;a[0]+1 &amp;a[1]&amp;a[0][0] 一个地址 指针 typeof(a[0][0])*ex：&amp;a[0][0]+1 &amp;a[0][1]注意：*和&amp;同时出现就抵消 *(a+1) a[1]一维数组*(&amp;a[0]+1)*(&amp;a[1])(*(a+1)+2)+3*(a[1] +2)+3 a[1][2]+3*(&amp;a[1][0]+2)+3*(&amp;a[1][2])+3]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数组]]></title>
    <url>%2F2018%2F09%2F06%2F%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[define NUM 1024int a[NUM];//NUM 是一个符号常量！ ex: int a[4] = {1,2,3,4};a[4] = 5;//非法的 因为 此处 n为4 下标为 0 - 3！ 这样就是越界的！printf(“%d”,a[4]);//语句指逻辑上不合法 其在编译器中依然不会报错！ 那么a[4]会打什么呢？1、可能是一个随机的垃圾值！原因那块地址并没有被初始化 所以里面的值是之前的残留值！ 2、也可能出现段错误 即核心已转储！当你超过了能够访问的范围！操作系统为每一个进程都分配了一段进程空间当你的操作超出了这段空间 你就无法访问 系统就会拦截你！3、由于gcc编译器做了优化 会将相同类型的数据存放在连续的地址空间中，所以可能会打印下一个变量的值！ ex: int a[4]; 使用typeof来求 即 typeof（a） = int[4]typeof用来求一个变量或者常量的数据类型的！typeof(a) 是不是一个合法的数据类型？是，那可不可以使用该类型再定义一个数组？即typeof(a) b[10];即在定义或者构造了一个新的类型 typeof(b);b是什么？ 也是一个数组不过称之为二维数组！ 二维数组的地址问题之前讲过 数组名即 首地址！首地址： 这个变量占用内存空间的第一个字节的编号！对于一个二维数组a而言！a = &amp;a[0]= a[0] = &amp;a[0][0]每一次取一个对象的地址 其实 取的是整个对象的地址 只是这个地址不能描述！所以只能是首地址来描述！思考如何将数组元素全部初始化为0？将第一个初始化为0即可！int a[3][3] ={0}; 二维数组的越界问题int a[3][3] = {1,2,3,4,5,6,7,8,9};printf(“%d”,a[0][3]);4原因：a[n] 作为右值时 是从a这个地址上偏移 sizeof(a[0]) 个单位的 内存上的值！想想a[0]的含义是 数组的第0行！ 那么其值为 首地址！也代表一个一维数组名！a[0][3]即从a[0]这个地址上开始偏移！a[1][4] = 8 从a[1]这个地址上偏移 sizeof(a[1][0])个单位内存上的值！只是替换了数组名而已！现在的数组名 加了一个[]而已！ 对于二维数组而言是不存在的 ！在计算机中只存在 一维数组！因为存储关系 所以 二维数组可以直接当做一维数组使用！ 字符串:关键词：\0C语言中并无字符串这样的数据类型一般情况下使用字符数组来表示字符串，但是必须要有一个结束符 ‘\0’;下面的案例就是一个没有结束束符的字符数组不能称之为 字符串！ex: char str1[] = {‘h’,’e’,’l’,’l’,’o’,’!’};sizeof(str1) = 6;原因其有6个元素！字符数组的长度就是字符数组所占的内存空间大小 即sizeof(数组名)； 而字符串的长度 就是从首地址开始到 ‘\0’结束，不包括‘\0’;在实际生活中并不关注 字符数组的长度，更多是在乎字符串的长度。 ex: char str2[10] = {‘h’,’e’,’l’,’l’,’o’,’!’};//请问上述是不是一个字符串？ 是!原因：这个字符数组的长度为10 填充了6个 其他的默认为0 而 0 == ‘\0’! 我们用 ‘\0’来区分字符串和字符数组！ 一个字符数组中如果有’\0’则就是一个字符串！ 字符串的表示：用双引号引起来的内容就是字符串自动添加’\0’!ex： char str3[] = “123456”;//一个字符串 其长度为 6 占用空间即大小为7char str4[10] = “123456”//是一个字符串 其长度为 6 占用空间即大小为 10！12345678910char ch[] = &#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;&#125;; sizeof(ch) = ? 3 strlen(ch) = ?//strlen求字符串长度的函数！ 不确定因为不知道何时碰到&apos;\0&apos;; char ch[] =&quot;123&quot;; sizeof(ch) = ? 4 strlen(ch) = ? 3 char ch[] = &#123;&apos;0&apos;,&apos;1&apos;,&apos;2&apos;,&apos;\0&apos;,&apos;5&apos;,&apos;6&apos;&#125;; sizeof(ch) = ? 6 strlen(ch) = ? 3 数组容量要求必须是正整数常量或常量表达式 memset(a,0,sizeof(a)); ===&gt; 将a指向的空间中 sizeof(a)==100个字节 清零 ★★★★除了清零作用外,一般不用memset 去操作非 字符数组123456789101112131415161718#include &lt;string.h&gt;strcpy: 将后一个字符串 拷贝到前一个字符串,从前一个字符串的第一个字符开始覆盖 char a[100] = &quot;skhsdjhjskdhjksdhjksdhjksd&quot;; char b[10] = &quot;hehehe&quot;; strcpy(a,b); ===&gt; a =&gt; hehehehjskdhjksdhjksdhjksd strncpy 将第二个字符串的前n个字符拷贝并覆盖 第一个字符串的前n个字符 如果第二个字符不够 n个 则自动补&apos;\0&apos; strncpy(a,b,2); //a ==&gt;hehsdjhjskdhjksdhjksdhjksd strncpy(a,b,8); // a==&gt; hehehe skdhjksdhjksdhjksd &apos;\0&apos;&apos;\0&apos;这里如果输出字符串则时hehehe因为遇到\0结束char str1[] = &quot;abcd&quot; ;char str2[2];strcpy(str2,&quot;123&quot;);printf(&quot;str1=%s\n&quot;,str1);printf(&quot;str2=%s\n&quot;,str2); 使用strcpy有个缺点：strcpy进行复制时，不进行数组越界的检查。str2数组只有2个字节，但是”123”却有4个字节，这是很明显的数组越界，但是GCC编译器编译中没有报错，也就是ctrcpy复制是不进行数组越界的检查。要避免这个问题，可以使用strncpy ，因为strncpy有参数n来限定复制的字节数。 strcat的作用是 将 src字符串(包括’\0’) 粘贴到 dest字符串后面,从dest字符串的 ‘\0’处开始粘贴要确保前一个字符数组的空间足够大否则 “段错误” 在等着你strncat 将src的前n个字符”拼接”到dest后面,并自定添加’\0’ “拼接”到前一个字符串后面,您要确保前一个字符数组的空间足够大否则 “段错误” 在等着你 strncat 将src的前n个字符”拼接”到dest后面,并自定添加’\0’ 使用strcpy有个缺点：strcpy进行复制时，不进行数组越界的检查。str2数组只有2个字节，但是”123”却有4个字节，这是很明显的数组越界，但是GCC编译器编译中没有报错，也就是ctrcpy复制是不进行数组越界的检查。要避免这个问题，可以使用strncpy ，因为strncpy有参数n来限定复制的字节数。字符串的比较,只能用strcmp来比较,不能用 == 实现自己的strlen strcpy strcat strcmp]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[数据间的运算规则]]></title>
    <url>%2F2018%2F09%2F05%2F%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[优先级！ &gt; 算术&gt; 关系&gt; &amp;&amp; &gt; || &gt; 赋值 &gt;逗号 需要熟悉ascii：‘0’ 48 0x30‘a’ 97‘A’ 65 数据在内存中存储的形式被称为 补码,所以上述可以简记为正数的补码就是原码负数的补码是绝对值的原码取反加1(注意区别为了方便人看而带符号的形式是不会出现在计算机中的） 比如:0x123456存储是:0000 0000 0001 0010 0011 0100 0101 0110 -1 存储在内存中是:0000 0000 0000 0000 0000 0000 0000 0001 (1)1111 1111 1111 1111 1111 1111 1111 1110 (~1)1111 1111 1111 1111 1111 1111 1111 1111 (~1 + 1 == -1) 注意:内存中的数据是不存在符号位的,全都是数据位符号位只存在与编译器中 短型 —&gt; 长型 高字节补位短型有符号: 高字节补符号位短型无符号: 高字节补 0 有符号赋值给无符号数据遵守无符号数据默认比有符号数据范围大！char -128 - 127unsigned char 0-255最大数明显255 &gt; 127 所以认为无符号数据的表示范围大于 有符号数unsigned int a ;int b = -1;a = b;printf(“%d”,a); ＝&gt; -1 原因是 %d 打印有符号整型printf(“%u”,a); =&gt;0xFFFFFFFF;说明输出由编译器决定。 浮点常量并不是float 而是double输出格式： %[flags][width][.prec][F|N|h|l]type(最后才是类型） 浮点数据存储：N = (-1)^s 1.M 2^(E-偏置量）12345678910111213141516171819202122232425每一个数据对应的位类型 符号位s 阶码E 尾数 总位数 偏置量float 1 8 23 32 127double 1 11 52 64 1023``` 浮点数据如何转化为二进制数据：ex:float f = 12.4561、整数部分直接转化为二进制 12 = &gt; 11002、小数部分转化为二进制：拿小数部分乘以2依次取整数直到没有小数为止 0.456 =》.0111 0100 1011 1100 0011 0101 ........ 最多取23位即可3、将小数部分与整数部分整合 1100.0111 0100 1011 1100 0011 01014、移动小数点表示成1.M的形式 并记录移动了多少位 1.1000 1110 1001 0111 1000 0110 101 保留小数点后23位即可： 1.1000 1110 1001 0111 1000 011 左移了3位5、求阶码 在偏置量的基础上 加减 如果左移+ 位数 如果右移 -位数 E = 130 6、整合填充 s E M0 1000 0010 100 0 1110 1001 0111 1000 011将这个数据推回10进制 看看是多少？`-1^s x(1.尾数偏移（E-127,取出整数部分）)此时整数部分就是12尾数计算1100.01110 1001 0111 1000 01102^-1 +12^-2………….计算出的结果： 12.45599699039…并不是12.456 原因就是浮点数据的存储 有精度的损耗！]]></content>
      <categories>
        <category>C语言</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[输入输出函数]]></title>
    <url>%2F2018%2F09%2F05%2F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[getchar()解析getchar()//单个字符putchar()gets//字符串putsinclude &lt;stdio.h&gt;printf/scanfprintf():123456789%d 打印10进制整型的 有符号%u 打印10进制整型的 无符号%c 打印一个字符%x 打印16进制数据%o 打印八进制数据%f 打印浮点数据%s 打印字符串的%p 打印地址的%g 打印时不输出无意义的0 scanf() 注意： scanf 的结束标志1、遇到非法字符 输入结束 比如 你要输入的是%d 一个整型而你输入了’n’ 就结束2、遇到空白符 比如 空格 回车 tab …..3、输入的宽度到了 就结束 比如 %3d 只能输入一个三位数 如果输入21345就结束了。强调： 在scanf输入中 格式化 怎么写就必须怎么输入 不能有任何不一致否则会出错对于初学者只建议使用占位符不要使用 其他符号。ex:int a,b,c,d;scanf(“%d %d %d %d\n”,&amp;a,&amp;b,&amp;c,&amp;d);输入时必须输入： ex： 1 2 3 4(回车)scanf(“%d%d%d%d”,&amp;a,&amp;b,&amp;c,&amp;d);输入只要以空白符作为间隔即可。 ex:1 2 3 4 (回车) ex:1 (回车)2 (回车)3 (回车)4 (回车)]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>printf和scanf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux常用命令]]></title>
    <url>%2F2018%2F08%2F27%2Flinux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[解压：tar1234567891011总结*.tar 用 tar –xvf 解压*.gz 用 gzip -d或者gunzip 解压*.tar.gz和*.tgz 用 tar –xzf 解压*.bz2 用 bzip2 -d或者用bunzip2 解压*.tar.bz2用tar –xjf 解压*.Z 用 uncompress 解压*.tar.Z 用tar –xZf 解压*.rar 用 unrar e解压*.zip 用 unzip 解压一般带个v显示过程 1234567891011121314151617181920212223242526272829303132333435363738394041-c: 建立压缩档案-x：解压-t：查看内容-r：向压缩归档文件末尾追加文件-u：更新原压缩包中的文件这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。-z：有gzip属性的-j：有bz2属性的-Z：有compress属性的-v：显示所有过程-O：将文件解开到标准输出下面的参数-f是必须的-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。# tar -cf all.tar *.jpg 这条命令是将所有.jpg的文件打成一个名为all.tar的包。-c是表示产生新的包，-f指定包的文件名。# tar -rf all.tar *.gif 这条命令是将所有.gif的文件增加到all.tar的包里面去。-r是表示增加文件的意思。# tar -uf all.tar logo.gif 这条命令是更新原来tar包all.tar中logo.gif文件，-u是表示更新文件的意思。# tar -tf all.tar 这条命令是列出all.tar包中所有文件，-t是列出文件的意思# tar -xf all.tar 这条命令是解出all.tar包中所有文件，-x是解开的意思压缩tar –cvf jpg.tar *.jpg 将目录里所有jpg文件打包成tar.jpgtar –czf jpg.tar.gz *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gztar –cjf jpg.tar.bz2 *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2tar –cZf jpg.tar.Z *.jpg 将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Zrar a jpg.rar *.jpg rar格式的压缩，需要先下载rar for linuxzip jpg.zip *.jpg zip格式的压缩，需要先下载zip for linux grep]]></content>
  </entry>
  <entry>
    <title><![CDATA[库的使用]]></title>
    <url>%2F2018%2F08%2F26%2F%E5%BA%93%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[jpeg图片显示使用了开源的库，编译时需要加-ljpeg这个就是动态库，还需将库放入开发板上，而编译时需要将jpeglib.h放到之前已经配置好的arm-linux-gcc 的那些文件夹bin：arm-linux。。。。。include：头文件lib：库share：似乎时man之类的说明文件]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>-使用库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[环境配置]]></title>
    <url>%2F2018%2F08%2F23%2F%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[ubuntu配置交叉编译工具：压缩包：arm-2009q3.tar.bz2 /usr/local/目录下创建一个arm目录 1sudo mkdir /usr/local/arm 将arm-2009q3.tar.bz2解压到创建的目录中 1sudo tar -xvf arm-2009q3.tar.bz2 -C /usr/local/arm/ 将该目录下所有的交叉编译工具(一个一个？简便方法？),利用ln创建符号链接文件,以方便简写 1sudo ln -s arm-none-linux-gnueabi-gcc arm-linux-gcc 将交叉编译工具所在的路径添加到 PATH 1sudo vi /etc/profile 在文件末尾添加:1export PATH=$PATH:/usr/local/arm/arm-2009q3/bin 上述语句,添加到 /etc/profile中,重启后,整个系统有效添加到 ~/.profile中,重启后,当前要用户有效./bashrc和/etc/profile的区别 TFTP1234sudo apt-get install tftpd-hpasudo service tftpd-hpa startsudo service tftpd-hpa stopsudo service tftpd-hpa restart 123456sudo vi /etc/default/tftpd-hpa //配置文件TFTP_USERNAME=&quot;tftp&quot; //tftp服务的用户名 TFTP_DIRECTORY=&quot;/home/gec/tftp&quot; //文件只能在该目录中下载TFTP_ADDRESS=&quot;0.0.0.0:69&quot; // tftp服务器的地址和端口TFTP_OPTIONS=&quot;-l -c -s&quot; //tftp服务的选项,不用管照抄 开发板使用：12tftp -g -r filename tftp_server_addr //下载tftp -p -l filename tftp_server_addr //上传 -g get 获取文件-r 递归-p put 发送文件-l local 本地的 NFS1234sudo apt-get install nfs-kernel-server//服务端sudo apt install nfs-common //客户端sudo service nfs-kernel-server start// 启动这些服务均可使用：service + 服务(tab)可以补全 123sudo vim /etc/exports/home/csgec/nfs *(rw,sync,no_root_squash)//* 代表所有IP均可访问 配置好开发板和ubuntu的IP，开发板使用：mount ip:/home/csgec/nfs /mnt Sambahttps://blog.csdn.net/qq_33775402/article/details/79511339 Bash关于./bashrc的配置更新命令：source ？？？？ 隐藏绝对路径]]></content>
      <categories>
        <category>日积月累</category>
      </categories>
      <tags>
        <tag>交叉环境配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim]]></title>
    <url>%2F2018%2F08%2F23%2Fvim%2F</url>
    <content type="text"><![CDATA[map :call SaveInputData()func! SaveInputData() exec “tabnew” exec ‘normal “+gP’ exec “w! /tmp/input_data”endfunc “colorscheme torte“colorscheme murphy“colorscheme desert“colorscheme desert“colorscheme elflordcolorscheme ron “set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936“set termencoding=utf-8“set encoding=utf-8“set fileencodings=ucs-bom,utf-8,cp936“set fileencoding=utf-8 “”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ 显示相关“”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“set shortmess=atI “ 启动的时候不显示那个援助乌干达儿童的提示“winpos 5 5 “ 设定窗口位置“set lines=40 columns=155 “ 设定窗口大小set go= “ 不要图形按钮“color asmanian2 “ 设置背景主题“set guifont=Courier_New:h10:cANSI “ 设置字体“syntax on “ 语法高亮autocmd InsertLeave se nocul “ 用浅色高亮当前行autocmd InsertEnter se cul “ 用浅色高亮当前行“set ruler “ 显示标尺set showcmd “ 输入的命令显示出来，看的清楚些“set cmdheight=1 “ 命令行（在状态行下）的高度，设置为1“set whichwrap+=&lt;,&gt;,h,l “ 允许backspace和光标键跨越行边界(不建议)“set scrolloff=3 “ 光标移动到buffer的顶部和底部时保持3行距离set novisualbell “ 不要闪烁(不明白)set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\”%d/%m/%y\ -\ %H:%M\”)} “状态行显示的内容set laststatus=1 “ 启动显示状态行(1),总是显示状态行(2)set foldenable “ 允许折叠set foldmethod=manual “ 手动折叠“set background=dark “背景使用黑色set nocompatible “去掉讨厌的有关vi一致性模式，避免以前版本的一些bug和局限“ 显示中文帮助if version &gt;= 603 set helplang=cn set encoding=utf-8endif“ 设置配色方案“colorscheme murphy“字体“if (has(“gui_running”))“ set guifont=Bitstream\ Vera\ Sans\ Mono\ 10“endif“””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“””””新文件标题“”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“新建.c,.h,.sh,.java文件，自动插入文件头autocmd BufNewFile .cpp,.[ch],.sh,.java exec “:call SetTitle()”“”定义函数SetTitle，自动插入文件头func SetTitle() “如果文件类型为.sh文件 if &amp;filetype == ‘sh’ call setline(1,”#########################################################################”) call append(line(“.”), “# File Name: “.expand(“%”)) call append(line(“.”)+1, “# Author: zxy”) call append(line(“.”)+2, “# mail: 310256030@qq.com“) call append(line(“.”)+3, “# Created Time: “.strftime(“%c”)) call append(line(“.”)+4, “#########################################################################”) call append(line(“.”)+5, “#!/bin/bash”) call append(line(“.”)+6, “”) else call setline(1, “/*“) call append(line(“.”), “ &gt; File Name: “.expand(“%”)) call append(line(“.”)+1, “ &gt; Author: zxy”) call append(line(“.”)+2, “ &gt; Mail: 310256030@qq.com“) call append(line(“.”)+3, “ &gt; Created Time: “.strftime(“%c”)) call append(line(“.”)+4, “ **/“) call append(line(“.”)+5, “”) endif if &amp;filetype == ‘cpp’ call append(line(“.”)+6, “#include“) call append(line(“.”)+7, “using namespace std;”) call append(line(“.”)+8, “”) endif if &amp;filetype == ‘c’ call append(line(“.”)+6, “#include&lt;stdio.h&gt;”) call append(line(“.”)+7, “”) call append(line(“.”)+8, “int main(void)”) call append(line(“.”)+9, “{“) call append(line(“.”)+10, “”) call append(line(“.”)+11, “ return 0;”) call append(line(“.”)+12, “}”) endif &quot; if &amp;filetype == &apos;java&apos; &quot; call append(line(&quot;.&quot;)+6,&quot;public class &quot;.expand(&quot;%&quot;)) &quot; call append(line(&quot;.&quot;)+7,&quot;&quot;) &quot; endif &quot;新建文件后，自动定位到文件末尾 autocmd BufNewFile * normal G endfunc“”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“键盘命令“””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””” nmap w :w!nmap f :find “ 映射全选+复制 ctrl+amap ggVGYmap! ggVGYmap gg=G“ 选中状态下 Ctrl+c 复制vmap “+y“去空行nnoremap :g/^\s*$/d“比较文件nnoremap :vert diffsplit“新建标签map :tabnew“列出当前目录文件map :tabnew .“打开树状文件目录map \be“C，C++ 按F5编译运行map :call CompileRunGcc()func! CompileRunGcc() exec “w” if &amp;filetype == ‘c’ exec “!g++ % -o %&lt;” exec “! ./%&lt;” elseif &amp;filetype == ‘cpp’ exec “!g++ % -o %&lt;” exec “! ./%&lt;” elseif &amp;filetype == ‘java’ exec “!javac %” exec “!java %&lt;” elseif &amp;filetype == ‘sh’ :!./% elseif &amp;filetype == ‘py’ exec “!python %” exec “!python %&lt;” endifendfunc“C,C++的调试map :call Rungdb()func! Rungdb() exec “w” exec “!g++ % -g -o %&lt;” exec “!gdb ./%&lt;”endfunc “”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“”实用设置“””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””“ 设置当文件被改动时自动载入set autoread“ quickfix模式autocmd FileType c,cpp map :w:make“代码补全set completeopt=preview,menu“允许插件filetype plugin on“共享剪贴板set clipboard+=unnamed“从不备份set nobackup“make 运行:set makeprg=g++\ -Wall\ \ %“自动保存set autowriteset ruler “ 打开状态栏标尺set cursorline “ 突出显示当前行set magic “ 设置魔术set guioptions-=T “ 隐藏工具栏set guioptions-=m “ 隐藏菜单栏“set statusline=\ %&lt;%F[%1%M%%n%R%H]%=\ %y\ %0(%{&amp;fileformat}\ %{&amp;encoding}\ %c:%l/%L%)\“ 设置在状态行显示的信息set foldcolumn=0set foldmethod=indentset foldlevel=3set foldenable “ 开始折叠“ 不要使用vi的键盘模式，而是vim自己的set nocompatible“ 语法高亮set syntax=on“ 去掉输入错误的提示声音set noeb“ 在处理未保存或只读文件的时候，弹出确认set confirm“ 自动缩进set autoindentset cindent“ Tab键的宽度set tabstop=4“ 统一缩进为4set softtabstop=4set shiftwidth=4“ 不要用空格代替制表符set noexpandtab“ 在行和段开始处使用制表符set smarttab“ 显示行号set number“ 历史记录数set history=1000“禁止生成临时文件set nobackupset noswapfile“搜索忽略大小写set ignorecase“搜索逐字符高亮set hlsearchset incsearch“行内替换set gdefault“编码设置set enc=utf-8set fencs=utf-8,ucs-bom,shift-jis,gb18030,gbk,gb2312,cp936“语言设置set langmenu=zh_CN.UTF-8set helplang=cn“ 我的状态行显示的内容（包括文件类型和解码）“set statusline=%F%m%r%h%w\ [FORMAT=%{&amp;ff}]\ [TYPE=%Y]\ [POS=%l,%v][%p%%]\ %{strftime(\”%d/%m/%y\ -\ %H:%M\”)}“set statusline=[%F]%y%r%m%%=[Line:%l/%L,Column:%c][%p%%]“ 总是显示状态行set laststatus=2“ 命令行（在状态行下）的高度，默认为1，这里是2set cmdheight=2“ 侦测文件类型filetype on“ 载入文件类型插件filetype plugin on“ 为特定文件类型载入相关缩进文件filetype indent on“ 保存全局变量set viminfo+=!“ 带有如下符号的单词不要被换行分割set iskeyword+=_,$,@,%,#,-“ 字符间插入的像素行数目set linespace=0“ 增强模式中的命令行自动完成操作set wildmenu“ 使回格键（backspace）正常处理indent, eol, start等set backspace=2“ 允许backspace和光标键跨越行边界set whichwrap+=&lt;,&gt;,h,l“ 可以在buffer的任何地方使用鼠标（类似office中在工作区双击鼠标定位）set mouse=aset selection=exclusiveset selectmode=mouse,key“ 通过使用: commands命令，告诉我们文件的哪一行被改变过set report=0“ 在被分割的窗口间显示空白，便于阅读set fillchars=vert:\ ,stl:\ ,stlnc:\“ 高亮显示匹配的括号set showmatch“ 匹配括号高亮的时间（单位是十分之一秒）set matchtime=1“ 光标移动到buffer的顶部和底部时保持3行距离set scrolloff=3“ 为C程序提供自动缩进set smartindent“ 高亮显示普通txt文件（需要txt.vim脚本）au BufRead,BufNewFile setfiletype txt“自动补全:inoremap ( ()i:inoremap ) =ClosePair(‘)’)“:inoremap { {}O“:inoremap } =ClosePair(‘}’):inoremap [ []i:inoremap ] =ClosePair(‘]’):inoremap “ “”i:inoremap ‘ ‘’ifunction! ClosePair(char) if getline(‘.’)[col(‘.’) - 1] == a:char return “\“ else return a:char endifendfunctionfiletype plugin indent on“打开文件类型检测, 加了这句才可以用智能补全set completeopt=longest,menu“”””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””””” “NERDtee设定let NERDChristmasTree=1let NERDTreeAutoCenter=1let NERDTreeBookmarksFile=$VIM.’\Data\NerdBookmarks.txt’let NERDTreeMouseMode=2let NERDTreeShowBookmarks=1let NERDTreeShowFiles=1let NERDTreeShowHidden=1let NERDTreeShowLineNumbers=1let NERDTreeWinPos=’left’let NERDTreeWinSize=31nnoremap f :NERDTreeTogglemap :NERDTree]]></content>
      <categories>
        <category>日积月累</category>
      </categories>
      <tags>
        <tag>-vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译技巧]]></title>
    <url>%2F2018%2F08%2F23%2F%E7%BC%96%E8%AF%91%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[头文件编写使用头文件的目的就是说明函数实现的功能以及函数里各封装函数的作用，方便在主函数调用。注意：多文件编译时只有一个.c文件有main()，其他都是函数，供main()调用。 123#ifndef __宏__ //如果没有定义该宏,则执行下列语句直到endif,#define __宏__ //该宏为了防止同一头文件被重复定义#endif //结束标识 库库:是一种代码的二进制封装形式,直接可以使用库是封装好的代码,一般与头文件一起给需要的人，库的存在有利于程序的模块化,而且如果函数接口设置的合理,改变库的实现,不会影响用户使用。 动态库 在借助动态库编译程序时,程序只是记录需要的资源所在动态库中的位置，在运行程序时,再跳转到该位置去执行相应的功能。 如上所述,程序在执行时还需要依赖动态库因此用户在下载自己的程序时,还需要下载动态库,并设置LD_LIBRARY_PAHTk(一般开发板上是放置到/usr/lib)。 编辑源代码 name.c &lt;— 功能函数的实现 (产品) name.h &lt;— 函数及数据类型等的说明(说明书) 生成动态库： libname.so 12345678(arm-linux-)gcc -shared -fpic name.c(可以多个.c文件) -o libname.so其中:-shared 表示编译生成动态库-fpic 表示生成的动态库与位置无关name.c 表示要封装成库的 源文件（无main函数）libname.so lib库文件的前缀 .so 动态库的后缀 name 库的名字 带动态库的程序编译: 123456789(arm-linux-)gcc ***.c -o *** -Iincpath -Llibpath -llibname -Iincpath 指定头文件搜索路径 incpath -Llibpath 指定库文件搜索路径 libpath -llibname 指定库名 为libname例子：gec@ubuntu:库$ gcc main.c -o main -I. -L. -lsqstackgec@ubuntu:库$ ./main./main: error while loading shared libraries: libsqstack.so: cannot open shared object file: No such file or directorygec@ubuntu:库$ //错误:在使用动态库libsqstack.so时:不能打开库的文件:没有这个文件或目录 因此在程序运行前,要将使用的库所在的路径添加到 LD_LIBRARY_PATH 环境变量中(编辑/etc/profile ???)export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:&lt;库所在目录的绝对路径&gt;也可以将库放到系统库的路径中 (/lib /usr/lib ….) 静态库: 在利用静态库编译程序时,程序会将静态库中的资源拷贝到自身程序中程序在运行时,就不需要静态库了，利用静态库编译的程序,往往会比较大。 编辑源代码 name.c &lt;— 功能函数的实现 (产品) name.h &lt;— 函数及数据类型等的说明(说明书) 生成静态库: libname.a 123(arm-linux-)gcc -c name.c -o name.o(arm-linux-)ar -rc libname.a name.o 编译静态库时,需要的文件是 中间文件(.o),因此在编译静态库前需要现将.c文件编成 .o 文件 带静态库编译 12345 (arm-linux-)gcc name.c -o -Iincpath -Llibpath -llibname -Iincpath 指定头文件搜索路径 incpath -Llibpath 指定库文件搜索路径 libpath -llibname 指定库名 为libname例子同上 利用静态库编译程序时,程序会将静态库中的资源全部拷贝到自身的程序文件中,直接下载程序就可以运行了,不需要下载库。]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>头文件</tag>
        <tag>动态库</tag>
        <tag>静态库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单Hexo教程]]></title>
    <url>%2F2018%2F07%2F30%2F%E7%AE%80%E5%8D%95Hexo%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[目录：准备：github环境、github.io已配置好 安装Hexo 初次本地体验Hexo 配置Hexo 下载及配置Next主题 安装Hexo 安装node.js npm install -g hexo 使用环境的几条命令 部署：npm install hexo-deployer-git –save 初次本地体验Hexo 创建一个hexo文件夹保存内容 hexo init（initial：初始化） hexo g（generate：生成） hexo s （hexo server：启动本地服务预览） 复制出现的 http://localhost:4000 到浏览器可以看到效果 注意：如果电脑没有显示可能是端口被占用，使用hexo s -p 5000换个端口，网址的4000换成5000即可。 配置Hexo打开根目录下的_config.yml文件开始配置 界面：最上面可以找到title（标题）然后下面的都是可以写的，根据个人喜好配置。注意language可以用zh-Hans就可以显示中文。 主题：找到theme后面改成next，等下会配置此主题 开启搜索选项： npm install hexo-generator-searchdb –save 部署：配置好后方便后续的推送，找到deploy 格式如下 type: git repo: git@github.com:youname/yourname.github.io.git branch: master Hexo的简单配置完成 下载及配置Next主题 Next下载（在根目录下输入）:git clone https://github.com/iissnan/hexo-theme-next themes/next 简单配置 风格：找到Schemes Pisces不错，去掉前面的#使用 头像：在最后添加avatar: /images/yours.png 搜索选项：Local search enable改为true 新建和推送 新建：hexo new （布局–开头需要那些东西可以直接生成，在scaffolds文件夹中，我写了一个c.md）名字（生成.md文件，生成时间和标签头）例子：hexo new c 数据结构） 推送：hexo g(生成动态文件)—&gt;hexo s -p 5000(预览）—&gt;hexo deploy(部署）]]></content>
      <categories>
        <category>学习有感</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
